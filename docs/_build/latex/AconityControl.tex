%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english,openany,oneside]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Aconity Control Documentation}
\date{Jul 11, 2019}
\release{0.0}
\author{Ricardo Dominguez-Olmedo}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Overview}
\label{\detokenize{overview:overview}}\label{\detokenize{overview::doc}}
This software package offers real-time modeling and optimisation of a laser
powder bed fusion process (AconityMINI). To do so, three scripts are executed
simultenously: \sphinxtitleref{aconity.py}, \sphinxtitleref{machine.py} and \sphinxtitleref{cluster.py}, the two former
executed locally in the AconityMINI computer and the latter executed in a remote
server for enhanced run-time performance.
\begin{itemize}
\item {} 
\sphinxtitleref{aconity.py}: Makes use of the API provided by Aconity to automatically start,
pause and resume a build, and to change individual part parameters in real-time.

\item {} 
\sphinxtitleref{machine.py}: Reads the raw sensory data outputted by the aconity machine,
processes it into a low-dimensional state vector and uploads it a remote server for
parameter optimisation.

\item {} 
\sphinxtitleref{cluster.py}: Computes optimal process parameters, at each layer, given
feedback obtained from the machine sensors. Based on the deep reinforcement
learning algorithm Probability Ensembles with Trajectory Sampling.

\end{itemize}


\section{Program flow}
\label{\detokenize{overview:program-flow}}\begin{quote}
\begin{itemize}
\item {} 
Layer is started by \sphinxtitleref{performLayer()} in \sphinxtitleref{aconity.py}

\item {} 
Pyrometer data is read and processed in real-time by \sphinxtitleref{getStates()} in \sphinxtitleref{machine.py}

\item {} 
When the layer is completed and all data has been read, the low-dimensional
processed states are sent to the remote server by \sphinxtitleref{sendStates()} in \sphinxtitleref{machine.py}

\item {} 
The states are received at the remote server by \sphinxtitleref{getStates()} in \sphinxtitleref{cluster.py}

\item {} 
A new control action is computed (build parameters are optimised) according
to the received feedback by \sphinxtitleref{computeAction} in \sphinxtitleref{cluster.py}

\item {} 
The computed actions are saved to the remote server by \sphinxtitleref{sendAction()} in \sphinxtitleref{cluster.py}

\item {} 
The computed actions are downloaded locally by \sphinxtitleref{getActions()} in \sphinxtitleref{machine.py}

\item {} 
A new layer is built using the updated parameters by \sphinxtitleref{performLayer()} in \sphinxtitleref{aconity.py}

\end{itemize}

The Aconity API software package provided by Aconity3D must be installed in the
computer connected to the Aconity machine according to Aconity’s guidelines. The
two files containing the bulk of the functionality of the API are \sphinxtitleref{AconitySTUDIO\_client.py}
and \sphinxtitleref{AconitySTUDIO\_utils.py}.
\end{quote}


\chapter{Installing, running and enhancing the software}
\label{\detokenize{installation:installing-running-and-enhancing-the-software}}\label{\detokenize{installation::doc}}

\section{Installing required dependencies}
\label{\detokenize{installation:installing-required-dependencies}}
The simplest way to install all required software packages is using \sphinxtitleref{conda}.

The modeling and optimisation software requires TensorFlow. This package can
be run on CPU or GPU (if one is available), the latter offering up to 100x faster
run time performance.

For a CPU installation use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{conda} \PYG{n}{create} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{n}{tf}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu} \PYG{n}{python}\PYG{o}{=}\PYG{l+m+mf}{3.5}
\PYG{n}{conda} \PYG{n}{activate} \PYG{n}{tf}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu}
\PYG{n}{conda} \PYG{n}{install} \PYG{n}{tensorflow}\PYG{o}{==}\PYG{l+m+mf}{1.10}
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{dotmap} \PYG{n}{scipy} \PYG{n}{gpflow} \PYG{n}{gym}\PYG{o}{==}\PYG{l+m+mf}{0.9}\PYG{o}{.}\PYG{l+m+mi}{4} \PYG{n}{pytest} \PYG{n}{tqdm} \PYG{n}{sklearn} \PYG{n}{scikit}\PYG{o}{\PYGZhy{}}\PYG{n}{optimize}
\end{sphinxVerbatim}

For a GPU installation use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{conda} \PYG{n}{create} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{n}{tf}\PYG{o}{\PYGZhy{}}\PYG{n}{gpu} \PYG{n}{python}\PYG{o}{=}\PYG{l+m+mf}{3.5}
\PYG{n}{conda} \PYG{n}{activate} \PYG{n}{tf}\PYG{o}{\PYGZhy{}}\PYG{n}{gpu}
\PYG{n}{conda} \PYG{n}{install} \PYG{n}{tensorflow}\PYG{o}{\PYGZhy{}}\PYG{n}{gpu}\PYG{o}{==}\PYG{l+m+mf}{1.10}
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{dotmap} \PYG{n}{scipy} \PYG{n}{gpflow} \PYG{n}{gym}\PYG{o}{==}\PYG{l+m+mf}{0.9}\PYG{o}{.}\PYG{l+m+mi}{4} \PYG{n}{pytest} \PYG{n}{tqdm} \PYG{n}{sklearn} \PYG{n}{scikit}\PYG{o}{\PYGZhy{}}\PYG{n}{optimize}
\end{sphinxVerbatim}

If there are dependencies missing, these can be installed using \sphinxtitleref{pip} or \sphinxtitleref{conda}
in the typical Python fashion.


\section{Running the software}
\label{\detokenize{installation:running-the-software}}
First, one must set the desired configuration for the build. The configuration files are:
\begin{itemize}
\item {} 
config\_cluster.py

\item {} 
config\_windows.py

\item {} 
config\_dmbrl.py

\end{itemize}

Details regarding the available configurations can be found under the \sphinxtitleref{Configuration} section.

After setting the desired configuration, one must:
\begin{itemize}
\item {} 
Run \sphinxtitleref{aconity.py} in the AconityComputer (i.e. using the Python IDLE), and wait until the command line displays \sphinxtitleref{“Waiting for actions…”}

\item {} 
Open MobaXterm
\begin{itemize}
\item {} 
Log into \sphinxtitleref{USERNAME@scentrohpc.shef.ac.uk} and provide the pertinent password.

\item {} 
Run \sphinxtitleref{source activate tf-cpu} (or whichever conda environment has the required dependencies)

\item {} 
Run \sphinxtitleref{cd software-path} where \sphinxtitleref{software-path} is the location of the software package on the remote server

\item {} 
Run \sphinxtitleref{python cluster.py}

\item {} 
Wait until the command line displays “Waiting for states…”

\end{itemize}

\item {} 
Run \sphinxtitleref{machine.py} (i.e. using the Python IDLE)

\end{itemize}


\section{Enhancing the software}
\label{\detokenize{installation:enhancing-the-software}}\begin{itemize}
\item {} 
To implement a different control strategy, modify the function \sphinxtitleref{computeAction()} in \sphinxtitleref{cluster.py}.

\item {} 
To make changes to the current control strategy, modify the relevant files within \sphinxtitleref{dmbrl/}

\item {} 
To change how the pyrometer measurements are converted into the low-dimensional features used for modeling and control, change the function \sphinxtitleref{getStates()} from \sphinxtitleref{machine.py}.

\end{itemize}


\subsection{Adding another sensor}
\label{\detokenize{installation:adding-another-sensor}}
To add another sensor one could change the function \sphinxtitleref{getStates()} from \sphinxtitleref{machine.py} to resemble:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{states} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n\PYGZus{}parts}\PYG{p}{,} \PYG{n}{M}\PYG{o}{+}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Initialise state vector}
\PYG{k}{for} \PYG{n}{part} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}parts}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Read information for all parts being monitored}
  \PYG{c+c1}{\PYGZsh{} Load raw data from sensors}
  \PYG{n}{data\PYGZus{}sensor1} \PYG{o}{=} \PYG{n}{loadSensor1}\PYG{p}{(}\PYG{n}{file\PYGZus{}path\PYGZus{}to\PYGZus{}part\PYGZus{}sensor1}\PYG{p}{)}
  \PYG{n}{data\PYGZus{}sensor2} \PYG{o}{=} \PYG{n}{loadSensor2}\PYG{p}{(}\PYG{n}{file\PYGZus{}path\PYGZus{}to\PYGZus{}part\PYGZus{}sensor2}\PYG{p}{)}

  \PYG{c+c1}{\PYGZsh{} Process raw data from sensors}
  \PYG{n}{state\PYGZus{}sensor1} \PYG{o}{=} \PYG{n}{processDataSensor1}\PYG{p}{(}\PYG{n}{data\PYGZus{}sensor1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} vector with shape (N,)}
  \PYG{n}{state\PYGZus{}sensor2} \PYG{o}{=} \PYG{n}{processDataSensor2}\PYG{p}{(}\PYG{n}{data\PYGZus{}sensor2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} vector with shape (M,)}

  \PYG{c+c1}{\PYGZsh{} Combine}
  \PYG{n}{state} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{concatenate}\PYG{p}{(}\PYG{p}{(}\PYG{n}{state\PYGZus{}sensor1}\PYG{p}{,} \PYG{n}{state\PYGZus{}sensor2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} shape (N+M,)}
  \PYG{n}{states}\PYG{p}{[}\PYG{n}{part}\PYG{p}{]} \PYG{o}{=} \PYG{n}{state}
\PYG{k}{return} \PYG{n}{states}
\end{sphinxVerbatim}

One would also need to ensure that the new state representation is suitable for
modeling the system with sufficient accuracy. To do so, convert the build
data of interest into the state representation to be tested, train the model
with the given state representation and check its accuracy in making predictions
over previously unseen data (R2, RMSE…). Take the following script for reference:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{tensorflow} \PYG{k}{as} \PYG{n+nn}{tf}
\PYG{k+kn}{from} \PYG{n+nn}{dotmap} \PYG{k}{import} \PYG{n}{DotMap}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{dmbrl}\PYG{n+nn}{.}\PYG{n+nn}{modeling}\PYG{n+nn}{.}\PYG{n+nn}{models} \PYG{k}{import} \PYG{n}{BNN}
\PYG{k+kn}{from} \PYG{n+nn}{dmbrl}\PYG{n+nn}{.}\PYG{n+nn}{modeling}\PYG{n+nn}{.}\PYG{n+nn}{layers} \PYG{k}{import} \PYG{n}{FC}

\PYG{n}{states} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{states\PYGZus{}file}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Dimension (n\PYGZus{}samples, n\PYGZus{}states)}
\PYG{n}{actions} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{actions\PYGZus{}file}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Dimension (n\PYGZus{}samples\PYGZhy{}1, n\PYGZus{}actions)}
\PYG{n}{XU} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{concatenate}\PYG{p}{(}\PYG{p}{(}\PYG{n}{X}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} inputs to the model}
\PYG{n}{Yd} \PYG{o}{=} \PYG{n}{X}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} training targets}

\PYG{c+c1}{\PYGZsh{} Split data into train and test sets}
\PYG{n}{test\PYGZus{}ratio} \PYG{o}{=} \PYG{l+m+mf}{0.2}
\PYG{n}{num\PYGZus{}test} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{X}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{n}{test\PYGZus{}ratio}\PYG{p}{)}
\PYG{n}{permutation} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{permutation}\PYG{p}{(}\PYG{n}{X}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{train\PYGZus{}x}\PYG{p}{,} \PYG{n}{test\PYGZus{}x} \PYG{o}{=} \PYG{n}{XU}\PYG{p}{[}\PYG{n}{permutation}\PYG{p}{[}\PYG{n}{num\PYGZus{}test}\PYG{p}{:}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{XU}\PYG{p}{[}\PYG{n}{permutation}\PYG{p}{[}\PYG{p}{:}\PYG{n}{num\PYGZus{}test}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{train\PYGZus{}y}\PYG{p}{,} \PYG{n}{test\PYGZus{}y} \PYG{o}{=} \PYG{n}{Yd}\PYG{p}{[}\PYG{n}{permutation}\PYG{p}{[}\PYG{n}{num\PYGZus{}test}\PYG{p}{:}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Yd}\PYG{p}{[}\PYG{n}{permutation}\PYG{p}{[}\PYG{p}{:}\PYG{n}{num\PYGZus{}test}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Before this, define the model parameters model\PYGZus{}in, model\PYGZus{}out, n\PYGZus{}layers, n\PYGZus{}neurons, l\PYGZus{}rate, wd\PYGZus{}in, wd\PYGZus{}hid, wd\PYGZus{}out, num\PYGZus{}networks}
\PYG{n}{sess} \PYG{o}{=} \PYG{n}{tf}\PYG{o}{.}\PYG{n}{Session}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{params} \PYG{o}{=} \PYG{n}{DotMap}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{model1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{num\PYGZus{}networks}\PYG{o}{=}\PYG{n}{num\PYGZus{}networks}\PYG{p}{,} \PYG{n}{sess}\PYG{o}{=}\PYG{n}{sess}\PYG{p}{)}
\PYG{n}{model} \PYG{o}{=} \PYG{n}{BNN}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{model}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{FC}\PYG{p}{(}\PYG{n}{n\PYGZus{}neurons}\PYG{p}{,} \PYG{n}{input\PYGZus{}dim}\PYG{o}{=}\PYG{n}{model\PYGZus{}in}\PYG{p}{,} \PYG{n}{activation}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{swish}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{weight\PYGZus{}decay}\PYG{o}{=}\PYG{n}{wd\PYGZus{}in}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}layers}\PYG{p}{)}\PYG{p}{:} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{model}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{FC}\PYG{p}{(}\PYG{n}{n\PYGZus{}neurons}\PYG{p}{,} \PYG{n}{activation}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{swish}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{weight\PYGZus{}decay}\PYG{o}{=}\PYG{n}{wd\PYGZus{}hid}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{FC}\PYG{p}{(}\PYG{n}{model\PYGZus{}out}\PYG{p}{,} \PYG{n}{weight\PYGZus{}decay}\PYG{o}{=}\PYG{n}{wd\PYGZus{}out}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{finalize}\PYG{p}{(}\PYG{n}{tf}\PYG{o}{.}\PYG{n}{train}\PYG{o}{.}\PYG{n}{AdamOptimizer}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{learning\PYGZus{}rate}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{l\PYGZus{}rate}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Train and make the predictions}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{train}\PYG{p}{(}\PYG{n}{train\PYGZus{}x}\PYG{p}{,} \PYG{n}{train\PYGZus{}y}\PYG{p}{,} \PYG{n}{batch\PYGZus{}size}\PYG{p}{,} \PYG{n}{training\PYGZus{}epochs}\PYG{p}{,} \PYG{n}{rescale}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{predicted\PYGZus{}y}\PYG{p}{,} \PYG{n}{var\PYGZus{}y} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{test\PYGZus{}x}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Essentially the mean and variance of the prediction, as it is a probabilistic model}

\PYG{c+c1}{\PYGZsh{} Compute metrics (R2 and RMSE should be previously define functions)}
\PYG{n}{r2\PYGZus{}metric} \PYG{o}{=} \PYG{n}{R2}\PYG{p}{(}\PYG{n}{test\PYGZus{}y}\PYG{p}{,} \PYG{n}{predicted\PYGZus{}y}\PYG{p}{)}
\PYG{n}{rmse\PYGZus{}metric} \PYG{o}{=} \PYG{n}{RMSE}\PYG{p}{(}\PYG{n}{test\PYGZus{}y}\PYG{p}{,} \PYG{n}{predicted\PYGZus{}y}\PYG{p}{)}
\end{sphinxVerbatim}

When incorporating a new sensor, you most likely want to change how the scaling
of the data is done, so that the magnitude of all your state elements is similar.
Otherwise model performance will be degraded. To change the scaler functionality, make changes
to \sphinxtitleref{dmbrl/modeling/utils/ModelScaler.py} as needed.


\subsection{Dividing a part into multiple “subparts”}
\label{\detokenize{installation:dividing-a-part-into-multiple-subparts}}
This approach aims to improve \sphinxtitleref{intra}-layer temperature homogeneity. There are
two sides to this problem. First, one probably wants to model the entire part as
one. To do so, one should combine the sensory information obtained for all subparts
into a single state vector, in a similar manner to explanation above (but instead
of combining sensors, combining parts).

Secondly, you must configure the MPC class to output more parameters. For instance, if you have
7 sub-parts and want to select distinct laser power and scan configurations in each
of them, then your action vector should have dimension 7 * 2 = 14. To change the dimension of the
vector, simply ensure all \sphinxtitleref{ac\_lb}, \sphinxtitleref{ac\_up} and \sphinxtitleref{constrains} variables fed to the \sphinxtitleref{MPC} class
have the correct dimension, i.e check that ac\_lb.shape==14, ac\_up.shape==14 and same with \sphinxtitleref{constrains}.

Then, you must make changes to the function \sphinxtitleref{performLayer()} within \sphinxtitleref{aconity.py} so that
the correct parts are addressed when changing the laser power and scan speed (must be able to handle
action inputs with secondary dimension \textgreater{} 2).


\chapter{Configuration parameters}
\label{\detokenize{config:configuration-parameters}}\label{\detokenize{config::doc}}
The desired configuration for the build is set on the following files:
\begin{itemize}
\item {} 
\sphinxtitleref{config\_windows.py}: General configuration parameters concerning the build, such as number of parts, build parameters, …

\item {} 
\sphinxtitleref{config\_dmbrl.py}: Low-level control specific configuration. Generally one would not need to change this file, but rather \sphinxtitleref{config\_cluster.py}

\item {} 
\sphinxtitleref{config\_cluster.py}: Control configuration, divided into ‘pretrained’ (model trained using data collected previously) and \sphinxtitleref{unfamiliar} (model learned in real-time).

\end{itemize}


\section{config\_windows.py}
\label{\detokenize{config:config-windows-py}}\begin{itemize}
\item {} 
LASER\_ON (bool): Laser is enabled when True.

\item {} 
JOB\_NAME (str): Job name as displayed in the AconitySTUDIO web application.

\item {} 
LAYERS (array of int): Layer range to be built, as {[}layer\_min, layer\_max{]}.

\item {} 
N\_PARTS (int): Number of parts to be built (not regarding ignored parts).

\item {} 
N\_STATES (int): Number of low-dimensional states used for the processing of the raw pyrometer data.

\item {} 
TEMPERATURE\_TARGET (float): Temperature target in mV.

\item {} 
N\_PARTS\_IGNORED (int): Number of additional parts to be built on top of \sphinxtitleref{N\_PARTS} (pyrometer may not record data for the first few parts).

\item {} 
IGNORED\_PARTS\_SPEED (float): Scan speed used for parts being “ignored”.

\item {} 
IGNORED\_PARTS\_POWER (float): Laser power used for parts being “ignored”.

\item {} 
N\_PARTS\_FIXED\_PARAMS (int): Number of parts built using fixed build parameters.

\item {} 
FIXED\_PARAMS (array): Parameters to be used for those parts being built with fixed build parameters, as {[}speed (m/s), power (W){]}

\item {} 
SLEEP\_TIME\_READING\_FILES (float): Time between a sensor data file being first detected and attempting to read it. Prevents errors emerging from opening the file while it is still being written.

\item {} 
PART\_DELTA (int): Parts of interest may increase 1 by 1, or 3 by 3 (refer to the AconitySTUDIO web application).

\end{itemize}


\section{config\_dmbrl.py and config\_cluster.py}
\label{\detokenize{config:config-dmbrl-py-and-config-cluster-py}}\begin{itemize}
\item {} 
ctrl\_cfg: Configuration parameters for the control algorithm.
\begin{quote}

-dO: dimensionality of observations
-dU: dimensionality of control inputs
- per: How often the action sequence will be optimized, i.e, for per=1 it is reoptimized at every call to \sphinxtitleref{MPC.act()}.
- constrains: {[}{[}np.array({[}min v, min q{]}), np.array({[}max v, max q{]}){]}, {[}min q/v, max q/v{]}, {[}min q/sqrt(v), max q/sqrt(v){]}{]}
- prop\_cfg: Configuration parameters for modeling and uncertainty propagation.
\begin{itemize}
\item {} 
model\_pretrained: \sphinxtitleref{True} if model used for MPC has been trained on previous data, \sphinxtitleref{False} otherwise.

\item {} 
model\_init\_cfg: Configuration parameters for model initialisation.
\begin{itemize}
\item {} 
ensemble\_size: Number of models within the ensemble.

\item {} 
load\_model: \sphinxtitleref{True} for a pretrained model to be loaded upon initialisation.

\item {} 
model\_dir: Directory in which the model files (.mat, .nns) are located.

\item {} 
model\_name: Name of the model files (model\_dir/model\_name.mat or model\_dir/model\_name.nns)

\end{itemize}

\item {} 
model\_train\_cfg: Configuration parameters for model training optimisation
\begin{itemize}
\item {} 
batch\_size: Batch size.

\item {} 
epochs: Number of training epochs.

\item {} 
hide\_progress: If ‘True’, additional information regarding model training is printed.

\end{itemize}

\item {} 
npart: Number of particles used for uncertainty propagation.

\item {} 
model\_in: Number of inputs to the model.

\item {} 
model\_out: Number of outputs to the model.

\item {} 
n\_layers: Number of hidden layers.

\item {} 
n\_neurons: Number of neurons per hidden layer.

\item {} 
learning\_rate: Learning rate.

\item {} 
wd\_in: Weight decay for the input layer neurons.

\item {} 
wd\_hid: Weight decay for the hidden layer neurons.

\item {} 
wd\_out: Weight decay for the output layer neurons.

\end{itemize}
\begin{itemize}
\item {} 
opt\_cfg: Configuration parameters for optimisation.
\begin{itemize}
\item {} 
mode: Uncertainty propagation method.

\item {} 
plan\_hor: Planning horizon for the model predictive control algorithm.

\item {} 
cfg
\begin{itemize}
\item {} 
popsize: Number of cost evaluations per iteration.

\item {} 
max\_iters: Maximum number of optimisation iterations.

\item {} 
num\_elites: Number of elites.

\item {} 
alpha: Alpha parametero of the CEM optimisation algorithm.

\item {} 
eps: Epsilon parameter of the CEM optimisation algorithm.

\end{itemize}

\item {} 
prop\_cfg
\begin{itemize}
\item {} 
mode: Uncertainty propagation method, ie “TSinf”

\end{itemize}

\end{itemize}

\item {} 
change\_target: True if multiple setpoints used, i.e. 980 and 1010

\item {} 
n\_parts\_targets: Number of parts to be built for each target

\item {} 
targets: Different temperature setpoints to be used (must be of same length as \sphinxtitleref{n\_parts\_targets})

\item {} 
force: Configuration parameters to periodically overwrite (“force”) predefined build parameters
\begin{itemize}
\item {} 
on: Force functionality enabled if True

\item {} 
start\_part: First part where functionality is enabled (disregarding the first few ignored parts)

\item {} 
n\_parts: Number of parts for which the functionality is enabled

\item {} 
n\_repeats: Number of consecutive layers for which inputs are forced. For {[}1,2{]}, n\_parts will be forced only once (periodically), while a further n\_parts will be forced two times consecutively (periodically)

\item {} 
init\_buffer: Initial number of layers for which parameters are not forced

\item {} 
upper\_init: Upper bound is initialised to this.

\item {} 
upper\_delta: Upper bound increases by this. For instance, for upper\_init=105 and upper\_delta=5, the upper bound sequence will be 105, 110, 115…

\item {} 
lower\_init: Lower bound is initialised to this.

\item {} 
lower\_delta: Lower bound is increased by this. For instance, for lower\_init=65 and lower\_delta=-5, the lower bound sequence will be 60, 55, 50…

\item {} 
fixed\_speed: For the forced parameters, power will be adjusted but mark speed will be kept fixed to this value.

\end{itemize}

\end{itemize}
\end{quote}

\end{itemize}


\chapter{Aconity API}
\label{\detokenize{aconityapi:aconity-api}}\label{\detokenize{aconityapi::doc}}

\section{Creating and configuring the client}
\label{\detokenize{aconityapi:creating-and-configuring-the-client}}
The client is created as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{AconitySTUDIO\PYGZus{}client} \PYG{k}{import} \PYG{n}{AconitySTUDIOPythonClient}

\PYG{n}{login\PYGZus{}data} \PYG{o}{=} \PYG{p}{\PYGZob{}}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rest\PYGZus{}url}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{http://192.168.1.1:9000}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ws\PYGZus{}url}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ws://192.168.1.1:9000}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{email}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{admin@yourcompany.com}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{password}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}password\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{client} \PYG{o}{=} \PYG{k}{await} \PYG{n}{AconitySTUDIOPythonClient}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{n}{login\PYGZus{}data}\PYG{p}{)}
\end{sphinxVerbatim}

Each job has a unique identifier which must be known in order to interact with said job.
To automatically gather and set the correct job id for the Python Client use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{await} \PYG{n}{client}\PYG{o}{.}\PYG{n}{get\PYGZus{}job\PYGZus{}id}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TestJob}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

This will automatically create an attribute \sphinxtitleref{job\_id}. From now on, if any method
of the Python Client would require a job id, you can omit this argument in the
function call. If you chose to explicitly fill in this parameter in a function
call, the clients own attribute (if it exists at all) will be ignored.

For normal operation of the Python Client, identifiers of the configuration and
the machine itself must be known aswell:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{await} \PYG{n}{client}\PYG{o}{.}\PYG{n}{get\PYGZus{}machine\PYGZus{}id}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{my\PYGZus{}unique\PYGZus{}machine\PYGZus{}name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{await} \PYG{n}{client}\PYG{o}{.}\PYG{n}{get\PYGZus{}config\PYGZus{}id}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{my\PYGZus{}unique\PYGZus{}config\PYGZus{}name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

If multiple machines, configurations or jobs exist with the same name, they need
to be looked up in the browser url field and given to the Python Client manually:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{client}\PYG{o}{.}\PYG{n}{job\PYGZus{}id} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{5c4bg4h21a00005a00581012}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{client}\PYG{o}{.}\PYG{n}{machine\PYGZus{}id} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{your\PYGZus{}machine\PYGZus{}id\PYGZus{}gathered\PYGZus{}from\PYGZus{}browser\PYGZus{}url\PYGZus{}bar}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{client}\PYG{o}{.}\PYG{n}{config\PYGZus{}id} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{your\PYGZus{}config\PYGZus{}id\PYGZus{}gathered\PYGZus{}from\PYGZus{}browser\PYGZus{}url\PYGZus{}bar}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}


\section{Script execution}
\label{\detokenize{aconityapi:script-execution}}
Use the \sphinxtitleref{execute()} coroutine. For instance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{light\PYGZus{}on} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}m.on(\PYGZdl{}c[light])}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{await} \PYG{n}{client}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{n}{channel}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{manual}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{script}\PYG{o}{=}\PYG{n}{light\PYGZus{}on}\PYG{p}{)}
\PYG{n}{movement} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}m.move\PYGZus{}rel(\PYGZdl{}c[slider], \PYGZhy{}180)}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{await} \PYG{n}{client}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{n}{channel}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{manual\PYGZus{}move}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{script}\PYG{o}{=}\PYG{n}{movement}\PYG{p}{)}
\end{sphinxVerbatim}

These commands get executed on different channels. If a channel is occupied,
any command sent to that channel will be ignored. The execute coroutine takes
care of this because if you await it, it will only yield control to its caller
once the channel is free again. This could be bypassed by commenting out some
of the source code.


\section{Job management}
\label{\detokenize{aconityapi:job-management}}
Job management comprises the starting, pausing, resuming and stopping of jobs.

For starting a job, we need to specify the job id, an execution script, and which
layers shall be built with which parts. If we have set the attribute job\_id and
all parts should be built, a job can be started like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{layers} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}build layer 1,2,3}

\PYG{n}{execution\PYGZus{}script} \PYG{o}{=} \PYGZbs{}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}layer = function()\PYGZob{}}
\PYG{l+s+sd}{for(p:\PYGZdl{}p)\PYGZob{}}
\PYG{l+s+sd}{  \PYGZdl{}m.expose(p[next;\PYGZdl{}h],\PYGZdl{}c[scanner\PYGZus{}1])}
\PYG{l+s+sd}{\PYGZcb{}}
\PYG{l+s+sd}{\PYGZdl{}m.add\PYGZus{}layer(\PYGZdl{}g)}
\PYG{l+s+sd}{\PYGZcb{}}
\PYG{l+s+sd}{repeat(layer)\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{k}{await} \PYG{n}{start\PYGZus{}job}\PYG{p}{(}\PYG{n}{layers}\PYG{p}{,} \PYG{n}{execution\PYGZus{}script}\PYG{p}{)}
\end{sphinxVerbatim}

This does not take care of starting a config or importing parameters from the
config into a job. This needs to be done in the GUI beforehand. Of course, it is
always possible to do the basic job configuration via the REST API in the Python
Client, but no convenience functions exist to simplify these tasks.

After a job is paused (\sphinxtitleref{await client.pause\_job(){}`}), one can change parameters.
For instance, subpart \sphinxtitleref{001\_s1\_vs} shall be exposed with a different laser power:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{part\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{}part\PYGZus{}id of 001\PYGZus{}s1\PYGZus{}vs. See next section {}`Documentation of all functions{}`.}
\PYG{n}{param} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{laser\PYGZus{}power}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{new\PYGZus{}laser\PYGZus{}power} \PYG{o}{=} \PYG{l+m+mi}{123}
\PYG{k}{await} \PYG{n}{client}\PYG{o}{.}\PYG{n}{change\PYGZus{}part\PYGZus{}parameter}\PYG{p}{(}\PYG{n}{part\PYGZus{}id}\PYG{p}{,} \PYG{n}{param}\PYG{p}{,} \PYG{n}{new\PYGZus{}value}\PYG{p}{)}
\end{sphinxVerbatim}

Changing a global parameter can be done via:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{param} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{supply\PYGZus{}factor}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{new\PYGZus{}value} \PYG{o}{=} \PYG{l+m+mf}{2.2}
\PYG{k}{await} \PYG{n}{client}\PYG{o}{.}\PYG{n}{change\PYGZus{}global\PYGZus{}parameter}\PYG{p}{(}\PYG{n}{param}\PYG{p}{,} \PYG{n}{new\PYGZus{}value}\PYG{p}{)}
\end{sphinxVerbatim}


\section{How pyrometer data is saved}
\label{\detokenize{aconityapi:how-pyrometer-data-is-saved}}
Pyrometer data is automatically saved by the AconityMINI as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{log}
  \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{n}{session\PYGZus{}2019\PYGZus{}03\PYGZus{}08\PYGZus{}16\PYGZus{}2etc} \PYG{o}{\PYGZhy{}} \PYG{n}{date}
    \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{n}{config\PYGZus{}1\PYGZus{}etc} \PYG{o}{\PYGZhy{}}
      \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{n}{job\PYGZus{}N\PYGZus{}id}
        \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{n}{sensors}
          \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{n}{Pyrometer}
            \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{n}{pyrometer2}
              \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{often} \PYG{n}{missing} \PYG{n}{files}
              \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}
                \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.03}\PYG{o}{.}\PYG{n}{pcd}
                \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06}\PYG{o}{.}\PYG{n}{pcd}
                \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.09}\PYG{o}{.}\PYG{n}{pcd}
                \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
              \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}
              \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

The session directory is created upon starting the AconitySTUDIO web application.
The config directory is created upon starting the \sphinxtitleref{Unheated 3D Monitoring} functionality.
The job folder is created upon starting script execution.


\chapter{Code documentation}
\label{\detokenize{code:code-documentation}}\label{\detokenize{code::doc}}

\section{aconity module}
\label{\detokenize{_modules/aconity:aconity-module}}\label{\detokenize{_modules/aconity::doc}}

\section{machine module}
\label{\detokenize{_modules/machine:module-machine}}\label{\detokenize{_modules/machine:machine-module}}\label{\detokenize{_modules/machine::doc}}\index{machine (module)@\spxentry{machine}\spxextra{module}}\index{Machine (class in machine)@\spxentry{Machine}\spxextra{class in machine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/machine:machine.Machine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{machine.}}\sphinxbfcode{\sphinxupquote{Machine}}}{\emph{shared\_cfg}, \emph{machine\_cfg}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Reads the raw sensory data outputted by the aconity machine, processes it
into a low-dimensional state vector and uploads it a remote server for
parameter optimisation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{shared\_cfg}} (\sphinxstyleliteralemphasis{\sphinxupquote{dotmap}}) \textendash{} \begin{itemize}
\item {} 
\sphinxstylestrong{n\_ignore} (\sphinxstyleemphasis{int}): Number of additional parts to be built on top of \sphinxtitleref{env.n\_parts} (pyrometer may not record data for the first few parts).

\item {} 
\sphinxstylestrong{env.nS} (\sphinxstyleemphasis{int}): Dimensionality of the state vector.

\item {} 
\sphinxstylestrong{comms} (\sphinxstyleemphasis{dotmap}): Configuration parameters for server communication.

\end{itemize}


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{machine\_cfg}} (\sphinxstyleliteralemphasis{\sphinxupquote{dotmap}}) \textendash{} \begin{itemize}
\item {} 
\sphinxstylestrong{aconity.layers} (\sphinxstyleemphasis{array of int}): Layer range to be built, as {[}layer\_min, layer\_max{]}.

\item {} 
\sphinxstylestrong{aconity.open\_loop} (\sphinxstyleemphasis{np.array}): Parameters used to build the parts built using fixed parameters, np.array with shape (\sphinxtitleref{n\_fixed\_parts}, 2).

\item {} 
\sphinxstylestrong{aconity.n\_parts} (\sphinxstyleemphasis{int}): Number of parts to be built, excluding ignored parts.

\item {} 
\sphinxstylestrong{process.sess\_dir} (\sphinxstyleemphasis{str}): Folder where pyrometer data is stored by the Aconity machine.

\item {} 
\sphinxstylestrong{process.sleep\_t} (\sphinxstyleemphasis{float}): Time between a sensor data file being first detected and attempting to read it. Prevents errors emerging from opening the file while it is still being written.

\end{itemize}


\end{itemize}

\end{description}\end{quote}
\index{getActions() (machine.Machine method)@\spxentry{getActions()}\spxextra{machine.Machine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/machine:machine.Machine.getActions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getActions}}}{}{}
Download locally the action file outputted by the remote server.

\end{fulllineitems}

\index{getFileName() (machine.Machine method)@\spxentry{getFileName()}\spxextra{machine.Machine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/machine:machine.Machine.getFileName}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getFileName}}}{\emph{layer}, \emph{piece}}{}
Returns the pyrometer data file path for a given layer and part number.

This function accounts for the parts being ignored. The layer thickness
is 0.03 mm.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{layer}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Layer number.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{piece}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Part number.

\end{itemize}

\item[{Returns}] \leavevmode
File path.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{getStates() (machine.Machine method)@\spxentry{getStates()}\spxextra{machine.Machine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/machine:machine.Machine.getStates}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getStates}}}{}{}
Read the raw data outputted from the pyrometer and processes it into
low-dimensional state vectors.

For every part that must be observed, the raw data is red from the file
outputted by the Aconity machine, cold lines are removed, the data pertaining
to the object manufactured is kept, and it is discretised into a number
of discrete regions in which the mean sensor value is computed.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
State vectors with shape (\sphinxtitleref{n\_parts},  \sphinxtitleref{nS})

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{initProcessing() (machine.Machine method)@\spxentry{initProcessing()}\spxextra{machine.Machine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/machine:machine.Machine.initProcessing}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{initProcessing}}}{}{}
Obtains the folder in which data will be written by the pyrometer sensor.

This function automatically detects the latest session and job folders.

\end{fulllineitems}

\index{log() (machine.Machine method)@\spxentry{log()}\spxextra{machine.Machine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/machine:machine.Machine.log}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{log}}}{\emph{states}}{}
\end{fulllineitems}

\index{loop() (machine.Machine method)@\spxentry{loop()}\spxextra{machine.Machine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/machine:machine.Machine.loop}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{loop}}}{}{}
Iteratively obtain next layer’s parameters from the remote server,
read and process raw pyrometer data, and upload the low-dimensional
states to the remote server to compute the next set of optimal parameters.

Allows the class functionality to be conveniently used as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{machine} \PYG{o}{=} \PYG{n}{Machine}\PYG{p}{(}\PYG{n}{s\PYGZus{}cfg}\PYG{p}{,} \PYG{n}{m\PYGZus{}cfg}\PYG{p}{)}
\PYG{n}{machine}\PYG{o}{.}\PYG{n}{loop}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{pieceNumber() (machine.Machine method)@\spxentry{pieceNumber()}\spxextra{machine.Machine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/machine:machine.Machine.pieceNumber}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pieceNumber}}}{\emph{piece\_indx}, \emph{buffer}}{}
Returns the index given by AconityStudio to each individual part.

For instance, if the first part should be ignored, and part numbers increase
three by three, then \sphinxtitleref{return int((piece\_indx+1)*3+1)} should be used, thus
0 -\textgreater{} 4, 1 -\textgreater{} 7, 2 -\textgreater{} 10, etc.

On the other hand, if the first three parts should be ignored, and part numbers
increase one by one, then \sphinxtitleref{return int((piece\_indx+3)+1)} should be used, thus
0 -\textgreater{} 4, 1 -\textgreater{} 5, 2 -\textgreater{} 6, etc.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{piece\_indx}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Input index, starting from 0.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_ignore}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of initial parts that should be ignored.

\end{itemize}

\item[{Returns}] \leavevmode
Output index as used by AconityStudio.

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{sendStates() (machine.Machine method)@\spxentry{sendStates()}\spxextra{machine.Machine method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/machine:machine.Machine.sendStates}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sendStates}}}{\emph{states}}{}
Uploads to the the remote server the input state vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{states}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}) \textendash{} Processed state vector.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{cluster module}
\label{\detokenize{_modules/cluster:module-cluster}}\label{\detokenize{_modules/cluster:cluster-module}}\label{\detokenize{_modules/cluster::doc}}\index{cluster (module)@\spxentry{cluster}\spxextra{module}}\index{Cluster (class in cluster)@\spxentry{Cluster}\spxextra{class in cluster}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/cluster:cluster.Cluster}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{cluster.}}\sphinxbfcode{\sphinxupquote{Cluster}}}{\emph{shared\_cfg}, \emph{pretrained\_cfg}, \emph{learned\_cfg}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Computes optimal process parameters, at each layer, given feedback obtained
from the machine sensors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{shared\_cfg}} (\sphinxstyleliteralemphasis{\sphinxupquote{dotmap}}) \textendash{} \begin{itemize}
\item {} 
\sphinxstylestrong{env.n\_parts} (\sphinxstyleemphasis{int}): Total number of parts built under feedback control.

\item {} 
\sphinxstylestrong{env.horizon} (\sphinxstyleemphasis{int}): Markov Decision Process horizon (here number of layers).

\item {} 
\sphinxstylestrong{env.nS} (\sphinxstyleemphasis{int}): Dimension of the state vector.

\item {} 
\sphinxstylestrong{comms} (\sphinxstyleemphasis{dotmap}): Parameters for communication with other classes.

\end{itemize}


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pretrained\_cfg}} (\sphinxstyleliteralemphasis{\sphinxupquote{dotmap}}) \textendash{} \begin{itemize}
\item {} 
\sphinxstylestrong{n\_parts} (\sphinxstyleemphasis{dotmap}): Number of parts built under this control scheme.

\item {} 
\sphinxstylestrong{ctrl\_cfg} (\sphinxstyleemphasis{dotmap}): Configuration parameters passed to the MPC class.

\end{itemize}


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{learned\_cfg}} (\sphinxstyleliteralemphasis{\sphinxupquote{dotmap}}) \textendash{} \begin{itemize}
\item {} 
\sphinxstylestrong{n\_parts} (\sphinxstyleemphasis{dotmap}): Number of parts built under this control scheme.

\item {} 
\sphinxstylestrong{ctrl\_cfg} (\sphinxstyleemphasis{dotmap}): Configuration parameters passed to the MPC class.

\end{itemize}


\end{itemize}

\end{description}\end{quote}
\index{clearComms() (cluster.Cluster method)@\spxentry{clearComms()}\spxextra{cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/cluster:cluster.Cluster.clearComms}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clearComms}}}{}{}
\end{fulllineitems}

\index{computeAction() (cluster.Cluster method)@\spxentry{computeAction()}\spxextra{cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/cluster:cluster.Cluster.computeAction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{computeAction}}}{\emph{states}}{}
Computes the control actions given the observed system states.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{states}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}) \textendash{} Observed states, shape (\sphinxtitleref{n\_parts}, \sphinxtitleref{nS})

\item[{Returns}] \leavevmode
Computed actions, with shape (\sphinxtitleref{n\_parts}, \sphinxtitleref{nU})

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{getStates() (cluster.Cluster method)@\spxentry{getStates()}\spxextra{cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/cluster:cluster.Cluster.getStates}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getStates}}}{}{}
Load state vectors uploaded to the server by the \sphinxtitleref{Machine} class.

This function waits for the \sphinxtitleref{comms.dir/comms.state.rdy\_name} folder to be
created by the \sphinxtitleref{Machine} class, before reading the file where the states
are located, \sphinxtitleref{comms.dir/comms.state.f\_name}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
State vector with shape (\sphinxtitleref{n\_parts}, \sphinxtitleref{nS})

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{initAction() (cluster.Cluster method)@\spxentry{initAction()}\spxextra{cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/cluster:cluster.Cluster.initAction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{initAction}}}{}{}
Returns the initial action vector.

This function is required because an initial layer must be built before
any feedback is available.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Initial action vector with shape (\sphinxtitleref{n\_parts}, \sphinxtitleref{nU})

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{log() (cluster.Cluster method)@\spxentry{log()}\spxextra{cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/cluster:cluster.Cluster.log}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{log}}}{}{}
Logs the state and action trajectories, as well as the predicted cost,
which may be of interest to tune some algorithmic parameters.

\end{fulllineitems}

\index{loop() (cluster.Cluster method)@\spxentry{loop()}\spxextra{cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/cluster:cluster.Cluster.loop}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{loop}}}{}{}
While within the time horizon, read the states provided by the \sphinxtitleref{Machine}
class, and compute and save the corresponding actions.

Allows the class functionality to be conveniently used as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cluster} \PYG{o}{=} \PYG{n}{Cluster}\PYG{p}{(}\PYG{n}{s\PYGZus{}cfg}\PYG{p}{,} \PYG{n}{cp\PYGZus{}cfg}\PYG{p}{,} \PYG{n}{cl\PYGZus{}cfg}\PYG{p}{)}
\PYG{n}{cluster}\PYG{o}{.}\PYG{n}{loop}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{sendAction() (cluster.Cluster method)@\spxentry{sendAction()}\spxextra{cluster.Cluster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/cluster:cluster.Cluster.sendAction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sendAction}}}{\emph{actions}}{}
Saves the computed actions.

Signals the \sphinxtitleref{Machine} class that actions are ready to be downloaded by
locally creating the \sphinxtitleref{comms.dir/comms.action.rdy\_name} folder
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{actions}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}) \textendash{} Action vector with shape (\sphinxtitleref{n\_parts}, \sphinxtitleref{nU})

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{controllers package}
\label{\detokenize{_modules/controllers:controllers-package}}\label{\detokenize{_modules/controllers::doc}}

\subsection{Submodules}
\label{\detokenize{_modules/controllers:submodules}}

\subsection{controllers.Controller module}
\label{\detokenize{_modules/controllers:module-controllers.Controller}}\label{\detokenize{_modules/controllers:controllers-controller-module}}\index{controllers.Controller (module)@\spxentry{controllers.Controller}\spxextra{module}}\index{Controller (class in controllers.Controller)@\spxentry{Controller}\spxextra{class in controllers.Controller}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/controllers:controllers.Controller.Controller}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{controllers.Controller.}}\sphinxbfcode{\sphinxupquote{Controller}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Framework of a controller class
\index{act() (controllers.Controller.Controller method)@\spxentry{act()}\spxextra{controllers.Controller.Controller method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/controllers:controllers.Controller.Controller.act}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{act}}}{\emph{obs}, \emph{t}, \emph{get\_pred\_cost=False}}{}
Performs an action.

\end{fulllineitems}

\index{dump\_logs() (controllers.Controller.Controller method)@\spxentry{dump\_logs()}\spxextra{controllers.Controller.Controller method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/controllers:controllers.Controller.Controller.dump_logs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dump\_logs}}}{\emph{primary\_logdir}, \emph{iter\_logdir}}{}
Dumps logs into primary log directory and per-train iteration log directory.

\end{fulllineitems}

\index{reset() (controllers.Controller.Controller method)@\spxentry{reset()}\spxextra{controllers.Controller.Controller method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/controllers:controllers.Controller.Controller.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Resets this controller.

\end{fulllineitems}

\index{train() (controllers.Controller.Controller method)@\spxentry{train()}\spxextra{controllers.Controller.Controller method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/controllers:controllers.Controller.Controller.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{obs\_trajs}, \emph{acs\_trajs}, \emph{rews\_trajs}}{}
Trains this controller using lists of trajectories.

\end{fulllineitems}


\end{fulllineitems}



\subsection{controllers.MPC module}
\label{\detokenize{_modules/controllers:module-controllers.MPC}}\label{\detokenize{_modules/controllers:controllers-mpc-module}}\index{controllers.MPC (module)@\spxentry{controllers.MPC}\spxextra{module}}\index{MPC (class in controllers.MPC)@\spxentry{MPC}\spxextra{class in controllers.MPC}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/controllers:controllers.MPC.MPC}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{controllers.MPC.}}\sphinxbfcode{\sphinxupquote{MPC}}}{\emph{params}}{}
Bases: {\hyperref[\detokenize{_modules/controllers:controllers.Controller.Controller}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{controllers.Controller.Controller}}}}}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{dotmap}}) \textendash{} 
Configuration parameters.
.env (gym.env):
\begin{quote}

Environment for which this controller will be used.
\end{quote}
\begin{description}
\item[{.update\_fns (list\textless{}func\textgreater{}):}] \leavevmode
A list of functions that will be invoked (possibly with a
tensorflow session) every time this controller is reset.

\item[{.ac\_ub (np.ndarray): (optional)}] \leavevmode
An array of action upper bounds. Defaults to environment action
upper bounds.

\item[{.ac\_lb (np.ndarray): (optional)}] \leavevmode
An array of action lower bounds. Defaults to environment action
lower bounds.

\item[{.per (int): (optional)}] \leavevmode
Determines how often the action sequence will be optimized.
Defaults to 1 (reoptimizes at every call to act()).

\item[{.prop\_cfg}] \leavevmode\begin{description}
\item[{.model\_init\_cfg (DotMap):}] \leavevmode
A DotMap of initialization parameters for the model.
.model\_constructor (func):
\begin{quote}

A function which constructs an instance of this model, given model\_init\_cfg.
\end{quote}

\item[{.model\_train\_cfg (dict): (optional)}] \leavevmode
A DotMap of training parameters that will be passed into the
model every time is is trained. Defaults to an empty dict.

\item[{.model\_pretrained (bool): (optional)}] \leavevmode
If True, assumes that the model has been trained upon construction.

\item[{.mode (str):}] \leavevmode
Propagation method. Choose between {[}E, DS, TSinf, TS1, MM{]}.
See \sphinxurl{https://arxiv.org/abs/1805.12114} for details.

\item[{.npart (int):}] \leavevmode
Number of particles used for DS, TSinf, TS1, and MM propagation methods.

\item[{.ign\_var (bool): (optional)}] \leavevmode
Determines whether or not variance output of the model will be ignored.
Defaults to False unless deterministic propagation is being used.

\item[{.obs\_preproc (func): (optional)}] \leavevmode
A function which modifies observations (in a 2D matrix) before
they are passed into the model. Defaults to lambda obs: obs.
Note: Must be able to process both NumPy and Tensorflow arrays.

\item[{.obs\_postproc (func): (optional)}] \leavevmode
A function which returns vectors calculated from the previous
observations and model predictions, which will then be passed
into the provided cost function on observations. Defaults to
lambda obs, model\_out: model\_out. Note: Must be able to process
both NumPy and Tensorflow arrays.

\item[{.obs\_postproc2 (func): (optional)}] \leavevmode
A function which takes the vectors returned by obs\_postproc and (possibly)
modifies it into the predicted observations for the next time step.
Defaults to lambda obs: obs. Note: Must be able to process both NumPy and Tensorflow arrays.

\item[{.targ\_proc (func): (optional)}] \leavevmode
A function which takes current observations and next observations
and returns the array of targets (so that the model learns the mapping
obs -\textgreater{} targ\_proc(obs, next\_obs)). Defaults to lambda obs, next\_obs: next\_obs.
Note: Only needs to process NumPy arrays.

\end{description}

\item[{.opt\_cfg}] \leavevmode\begin{description}
\item[{.mode (str):}] \leavevmode
Internal optimizer that will be used. Choose between {[}CEM, Random{]}.

\item[{.cfg (DotMap):}] \leavevmode
A map of optimizer initializer parameters.

\item[{.plan\_hor (int):}] \leavevmode
The planning horizon that will be used in optimization.

\item[{.obs\_cost\_fn (func):}] \leavevmode
A function which computes the cost of every observation in a 2D matrix.
Note: Must be able to process both NumPy and Tensorflow arrays.

\item[{.ac\_cost\_fn (func):}] \leavevmode
A function which computes the cost of every action in a 2D matrix.

\item[{.constrains (np.array):}] \leavevmode
An array with the optimisation constrains = {[}{[}lb, ub{]}, {[}lc1, uc1{]}, {[}lc2, uc2{]}{]}
so that if u = {[}v, q{]}, lb \textless{}= u \textless{}= ub, lc1 \textless{}= q/v \textless{}= uc2, lc2 \textless{}= q/sqrt(v) \textless{}= uc2.
Overwrites ac\_lb and ac\_ub is constrains{[}0{]} is not None.

\end{description}

\item[{.log\_cfg}] \leavevmode\begin{description}
\item[{.save\_all\_models (bool): (optional)}] \leavevmode
If True, saves models at every iteration.
Defaults to False (only most recent model is saved).
Warning: Can be very memory-intensive.

\item[{.log\_traj\_preds (bool): (optional)}] \leavevmode
If True, saves the mean and variance of predicted particle trajectories.
Defaults to False.

\item[{.log\_particles (bool) (optional)}] \leavevmode
If True, saves all predicted particles trajectories.
Defaults to False. Note: Takes precedence over log\_traj\_preds.
Warning: Can be very memory-intensive

\end{description}

\end{description}


\end{description}\end{quote}
\index{act() (controllers.MPC.MPC method)@\spxentry{act()}\spxextra{controllers.MPC.MPC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/controllers:controllers.MPC.MPC.act}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{act}}}{\emph{obs}, \emph{t}, \emph{get\_pred\_cost=False}}{}
Returns the action that this controller would take at time t given observation obs.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs}} \textendash{} The current observation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} The current timestep

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{get\_pred\_cost}} \textendash{} If True, returns the predicted cost for the action sequence found by
the internal optimizer.

\end{itemize}

\end{description}\end{quote}

Returns: An action (and possibly the predicted cost)

\end{fulllineitems}

\index{changePlanHor() (controllers.MPC.MPC method)@\spxentry{changePlanHor()}\spxextra{controllers.MPC.MPC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/controllers:controllers.MPC.MPC.changePlanHor}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{changePlanHor}}}{\emph{T}, \emph{freq=None}, \emph{change\_over=False}}{}
Dynamically changes the planning horizon of the MPC algorithm.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{T}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} New planning horizon.

\end{description}\end{quote}

\end{fulllineitems}

\index{changeTargetCost() (controllers.MPC.MPC method)@\spxentry{changeTargetCost()}\spxextra{controllers.MPC.MPC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/controllers:controllers.MPC.MPC.changeTargetCost}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{changeTargetCost}}}{\emph{target}}{}
\end{fulllineitems}

\index{dump\_logs() (controllers.MPC.MPC method)@\spxentry{dump\_logs()}\spxextra{controllers.MPC.MPC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/controllers:controllers.MPC.MPC.dump_logs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dump\_logs}}}{\emph{primary\_logdir}, \emph{iter\_logdir}}{}
Saves logs to either a primary log directory or another iteration-specific directory.
See \_\_init\_\_ documentation to see what is being logged.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{primary\_logdir}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} A directory path. This controller assumes that this directory
does not change every iteration.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iter\_logdir}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} A directory path. This controller assumes that this directory
changes every time dump\_logs is called.

\end{itemize}

\end{description}\end{quote}

Returns: None

\end{fulllineitems}

\index{optimizers (controllers.MPC.MPC attribute)@\spxentry{optimizers}\spxextra{controllers.MPC.MPC attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/controllers:controllers.MPC.MPC.optimizers}}\pysigline{\sphinxbfcode{\sphinxupquote{optimizers}}\sphinxbfcode{\sphinxupquote{ = \{'CEM': \textless{}class 'dmbrl.misc.optimizers.cem.CEMOptimizer'\textgreater{}, 'Random': \textless{}class 'dmbrl.misc.optimizers.random.RandomOptimizer'\textgreater{}\}}}}
\end{fulllineitems}

\index{reset() (controllers.MPC.MPC method)@\spxentry{reset()}\spxextra{controllers.MPC.MPC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/controllers:controllers.MPC.MPC.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Resets this controller (clears previous solution, calls all update functions).

Returns: None

\end{fulllineitems}

\index{train() (controllers.MPC.MPC method)@\spxentry{train()}\spxextra{controllers.MPC.MPC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/controllers:controllers.MPC.MPC.train}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{train}}}{\emph{obs\_trajs}, \emph{obs\_prime\_trajs}, \emph{acs\_trajs}}{}
Trains the internal model of this controller. Once trained,
this controller switches from applying random actions to using MPC.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_trajs}} \textendash{} (N, nS)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obs\_prime\_trajs}} \textendash{} (N, nS) observations at next time step

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{acs\_trajs}} \textendash{} (N, nU)

\end{itemize}

\end{description}\end{quote}

Returns: None.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Module contents}
\label{\detokenize{_modules/controllers:module-controllers}}\label{\detokenize{_modules/controllers:module-contents}}\index{controllers (module)@\spxentry{controllers}\spxextra{module}}

\section{layers package}
\label{\detokenize{_modules/layers:layers-package}}\label{\detokenize{_modules/layers::doc}}

\subsection{Submodules}
\label{\detokenize{_modules/layers:submodules}}

\subsection{layers.FC module}
\label{\detokenize{_modules/layers:module-layers.FC}}\label{\detokenize{_modules/layers:layers-fc-module}}\index{layers.FC (module)@\spxentry{layers.FC}\spxextra{module}}\index{FC (class in layers.FC)@\spxentry{FC}\spxextra{class in layers.FC}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{layers.FC.}}\sphinxbfcode{\sphinxupquote{FC}}}{\emph{output\_dim}, \emph{input\_dim=None}, \emph{activation=None}, \emph{weight\_decay=None}, \emph{ensemble\_size=1}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Represents a fully-connected layer in a network.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_dim}} \textendash{} (int) The dimensionality of the output of this layer.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{input\_dim}} \textendash{} (int/None) The dimensionality of the input of this layer.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{activation}} \textendash{} (str/None) The activation function applied on the outputs.
See FC.\_activations to see the list of allowed strings.
None applies the identity function.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weight\_decay}} \textendash{} (float) The rate of weight decay applied to the weights of this layer.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ensemble\_size}} \textendash{} (int) The number of networks in the ensemble within which this layer will be used.

\end{itemize}

\end{description}\end{quote}
\index{compute\_output\_tensor() (layers.FC.FC method)@\spxentry{compute\_output\_tensor()}\spxextra{layers.FC.FC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC.compute_output_tensor}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_output\_tensor}}}{\emph{input\_tensor}}{}
Returns the resulting tensor when all operations of this layer are applied to input\_tensor.

If input\_tensor is 2D, this method returns a 3D tensor representing the output of each
layer in the ensemble on the input\_tensor. Otherwise, if the input\_tensor is 3D, the output
is also 3D, where output{[}i{]} = layer\_ensemble{[}i{]}(input{[}i{]}).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{input\_tensor}} \textendash{} (tf.Tensor) The input to the layer.

\end{description}\end{quote}

Returns: The output of the layer, as described above.

\end{fulllineitems}

\index{construct\_vars() (layers.FC.FC method)@\spxentry{construct\_vars()}\spxextra{layers.FC.FC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC.construct_vars}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{construct\_vars}}}{}{}
Constructs the variables of this fully-connected layer.

Returns: None

\end{fulllineitems}

\index{copy() (layers.FC.FC method)@\spxentry{copy()}\spxextra{layers.FC.FC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{sess=None}}{}
Returns a Layer object with the same parameters as this layer.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sess}} \textendash{} (tf.Session/None) session containing the current values of the variables to be copied. Must be passed in to copy values.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{copy\_vals}} \textendash{} (bool) Indicates whether variable values will be copied over. Ignored if the variables of this layer has not yet been constructed.

\end{itemize}

\end{description}\end{quote}

Returns: The copied layer.

\end{fulllineitems}

\index{get\_activation() (layers.FC.FC method)@\spxentry{get\_activation()}\spxextra{layers.FC.FC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC.get_activation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_activation}}}{\emph{as\_func=True}}{}
Returns the current activation function for this layer.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{as\_func}} \textendash{} (bool) Determines whether the returned value is the string corresponding to the activation function or the activation function itself.

\end{description}\end{quote}

Returns: The activation function (string/function, see as\_func argument for details).

\end{fulllineitems}

\index{get\_decays() (layers.FC.FC method)@\spxentry{get\_decays()}\spxextra{layers.FC.FC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC.get_decays}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_decays}}}{}{}
Returns the list of losses corresponding to the weight decay imposed on each weight of the
network.

Returns: the list of weight decay losses.

\end{fulllineitems}

\index{get\_ensemble\_size() (layers.FC.FC method)@\spxentry{get\_ensemble\_size()}\spxextra{layers.FC.FC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC.get_ensemble_size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_ensemble\_size}}}{}{}
Returns the ensemble size.

Returns: int

\end{fulllineitems}

\index{get\_input\_dim() (layers.FC.FC method)@\spxentry{get\_input\_dim()}\spxextra{layers.FC.FC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC.get_input_dim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_input\_dim}}}{}{}
Returns the dimension of the input.

Returns: The dimension of the input

\end{fulllineitems}

\index{get\_output\_dim() (layers.FC.FC method)@\spxentry{get\_output\_dim()}\spxextra{layers.FC.FC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC.get_output_dim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_output\_dim}}}{}{}
Returns the dimension of the output.

Returns: The dimension of the output.

\end{fulllineitems}

\index{get\_vars() (layers.FC.FC method)@\spxentry{get\_vars()}\spxextra{layers.FC.FC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC.get_vars}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_vars}}}{}{}
Returns the variables of this layer.

\end{fulllineitems}

\index{get\_weight\_decay() (layers.FC.FC method)@\spxentry{get\_weight\_decay()}\spxextra{layers.FC.FC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC.get_weight_decay}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_weight\_decay}}}{}{}
Returns the current rate of weight decay set for this layer.

Returns: The weight decay rate.

\end{fulllineitems}

\index{set\_activation() (layers.FC.FC method)@\spxentry{set\_activation()}\spxextra{layers.FC.FC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC.set_activation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_activation}}}{\emph{activation}}{}
Sets the activation function for this layer.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{activation}} \textendash{} (str) The activation function to be used.

\end{description}\end{quote}

Returns: None.

\end{fulllineitems}

\index{set\_ensemble\_size() (layers.FC.FC method)@\spxentry{set\_ensemble\_size()}\spxextra{layers.FC.FC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC.set_ensemble_size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_ensemble\_size}}}{\emph{ensemble\_size}}{}
Sets the ensemble size.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ensemble\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} 

\end{description}\end{quote}

Returns: None

\end{fulllineitems}

\index{set\_input\_dim() (layers.FC.FC method)@\spxentry{set\_input\_dim()}\spxextra{layers.FC.FC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC.set_input_dim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_input\_dim}}}{\emph{input\_dim}}{}
Sets the dimension of the input.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{input\_dim}} \textendash{} (int) The dimension of the input.

\end{description}\end{quote}

Returns: None

\end{fulllineitems}

\index{set\_output\_dim() (layers.FC.FC method)@\spxentry{set\_output\_dim()}\spxextra{layers.FC.FC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC.set_output_dim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_output\_dim}}}{\emph{output\_dim}}{}
Sets the dimension of the output.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{output\_dim}} \textendash{} (int) The dimension of the output.

\end{description}\end{quote}

Returns: None.

\end{fulllineitems}

\index{set\_weight\_decay() (layers.FC.FC method)@\spxentry{set\_weight\_decay()}\spxextra{layers.FC.FC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC.set_weight_decay}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_weight\_decay}}}{\emph{weight\_decay}}{}
Sets the current weight decay rate for this layer.

Returns: None

\end{fulllineitems}

\index{unset\_activation() (layers.FC.FC method)@\spxentry{unset\_activation()}\spxextra{layers.FC.FC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC.unset_activation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{unset\_activation}}}{}{}
Removes the currently set activation function for this layer.

Returns: None

\end{fulllineitems}

\index{unset\_weight\_decay() (layers.FC.FC method)@\spxentry{unset\_weight\_decay()}\spxextra{layers.FC.FC method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/layers:layers.FC.FC.unset_weight_decay}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{unset\_weight\_decay}}}{}{}
Removes weight decay from this layer.

Returns: None

\end{fulllineitems}


\end{fulllineitems}



\subsection{Module contents}
\label{\detokenize{_modules/layers:module-layers}}\label{\detokenize{_modules/layers:module-contents}}\index{layers (module)@\spxentry{layers}\spxextra{module}}

\section{misc package}
\label{\detokenize{_modules/misc:misc-package}}\label{\detokenize{_modules/misc::doc}}

\subsection{Subpackages}
\label{\detokenize{_modules/misc:subpackages}}

\subsubsection{misc.optimizers package}
\label{\detokenize{_modules/misc.optimizers:misc-optimizers-package}}\label{\detokenize{_modules/misc.optimizers::doc}}

\paragraph{Submodules}
\label{\detokenize{_modules/misc.optimizers:submodules}}

\paragraph{misc.optimizers.cem module}
\label{\detokenize{_modules/misc.optimizers:module-misc.optimizers.cem}}\label{\detokenize{_modules/misc.optimizers:misc-optimizers-cem-module}}\index{misc.optimizers.cem (module)@\spxentry{misc.optimizers.cem}\spxextra{module}}\index{CEMOptimizer (class in misc.optimizers.cem)@\spxentry{CEMOptimizer}\spxextra{class in misc.optimizers.cem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/misc.optimizers:misc.optimizers.cem.CEMOptimizer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{misc.optimizers.cem.}}\sphinxbfcode{\sphinxupquote{CEMOptimizer}}}{\emph{sol\_dim}, \emph{max\_iters}, \emph{popsize}, \emph{num\_elites}, \emph{constrains}, \emph{tf\_session=None}, \emph{epsilon=0.001}, \emph{alpha=0.25}, \emph{max\_resamples=10}}{}
Bases: {\hyperref[\detokenize{_modules/misc.optimizers:misc.optimizers.optimizer.Optimizer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{misc.optimizers.optimizer.Optimizer}}}}}

A Tensorflow-compatible CEM optimizer.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sol\_dim}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The dimensionality of the problem space

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{max\_iters}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The maximum number of iterations to perform during optimization

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{popsize}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of candidate solutions to be sampled at every iteration

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{num\_elites}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of top solutions that will be used to obtain the distribution at the next iteration.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{constrains}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}) \textendash{} {[}{[}np.array({[}min v, min q{]}), np.array({[}max v, max q{]}){]}, {[}min q/v, max q/v{]}, {[}min q/sqrt(v), max q/sqrt(v){]}{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tf\_session}} (\sphinxstyleliteralemphasis{\sphinxupquote{tf.Session}}) \textendash{} (optional) Session to be used for this optimizer. Defaults to None, in which case any functions passed in cannot be tf.Tensor-valued.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{epsilon}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} A minimum variance. If the maximum variance drops below epsilon, optimization is stopped.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Controls how much of the previous mean and variance is used for the next iteration. next\_mean = alpha * old\_mean + (1 - alpha) * elite\_mean, and similarly for variance.

\end{itemize}

\end{description}\end{quote}
\index{changeSolDim() (misc.optimizers.cem.CEMOptimizer method)@\spxentry{changeSolDim()}\spxextra{misc.optimizers.cem.CEMOptimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/misc.optimizers:misc.optimizers.cem.CEMOptimizer.changeSolDim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{changeSolDim}}}{\emph{sol\_dim}}{}
Change the dimension of the CEM optimisation solution.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{sol\_dim}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} New dimension of the CEM optimisation solution.

\end{description}\end{quote}

\end{fulllineitems}

\index{obtain\_solution() (misc.optimizers.cem.CEMOptimizer method)@\spxentry{obtain\_solution()}\spxextra{misc.optimizers.cem.CEMOptimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/misc.optimizers:misc.optimizers.cem.CEMOptimizer.obtain_solution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{obtain\_solution}}}{\emph{init\_mean}, \emph{init\_var}}{}
Optimizes the cost function using the provided initial candidate distribution
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{init\_mean}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} The mean of the initial candidate distribution.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{init\_var}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} The variance of the initial candidate distribution.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{reset() (misc.optimizers.cem.CEMOptimizer method)@\spxentry{reset()}\spxextra{misc.optimizers.cem.CEMOptimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/misc.optimizers:misc.optimizers.cem.CEMOptimizer.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Blank function for compatibility with optimisation class framework.

\end{fulllineitems}

\index{setup() (misc.optimizers.cem.CEMOptimizer method)@\spxentry{setup()}\spxextra{misc.optimizers.cem.CEMOptimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/misc.optimizers:misc.optimizers.cem.CEMOptimizer.setup}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setup}}}{\emph{cost\_function}, \emph{tf\_compatible}}{}
Sets up this optimizer using a given cost function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cost\_function}} (\sphinxstyleliteralemphasis{\sphinxupquote{func}}) \textendash{} A function for computing costs over a batch of candidate solutions.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tf\_compatible}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} True if the cost function provided is tf.Tensor-valued.

\end{itemize}

\end{description}\end{quote}

Returns: None

\end{fulllineitems}


\end{fulllineitems}



\paragraph{misc.optimizers.optimizer module}
\label{\detokenize{_modules/misc.optimizers:module-misc.optimizers.optimizer}}\label{\detokenize{_modules/misc.optimizers:misc-optimizers-optimizer-module}}\index{misc.optimizers.optimizer (module)@\spxentry{misc.optimizers.optimizer}\spxextra{module}}\index{Optimizer (class in misc.optimizers.optimizer)@\spxentry{Optimizer}\spxextra{class in misc.optimizers.optimizer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/misc.optimizers:misc.optimizers.optimizer.Optimizer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{misc.optimizers.optimizer.}}\sphinxbfcode{\sphinxupquote{Optimizer}}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Framework for Optimizer subclasses
\index{obtain\_solution() (misc.optimizers.optimizer.Optimizer method)@\spxentry{obtain\_solution()}\spxextra{misc.optimizers.optimizer.Optimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/misc.optimizers:misc.optimizers.optimizer.Optimizer.obtain_solution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{obtain\_solution}}}{\emph{*args}, \emph{**kwargs}}{}
Compute optimisation problem solution

\end{fulllineitems}

\index{reset() (misc.optimizers.optimizer.Optimizer method)@\spxentry{reset()}\spxextra{misc.optimizers.optimizer.Optimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/misc.optimizers:misc.optimizers.optimizer.Optimizer.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Function iteratively called at MPC.act()

\end{fulllineitems}

\index{setup() (misc.optimizers.optimizer.Optimizer method)@\spxentry{setup()}\spxextra{misc.optimizers.optimizer.Optimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/misc.optimizers:misc.optimizers.optimizer.Optimizer.setup}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setup}}}{\emph{cost\_function}, \emph{tf\_compatible}}{}
Function called upon initialisation of the MPC class.

\end{fulllineitems}


\end{fulllineitems}



\paragraph{misc.optimizers.random module}
\label{\detokenize{_modules/misc.optimizers:module-misc.optimizers.random}}\label{\detokenize{_modules/misc.optimizers:misc-optimizers-random-module}}\index{misc.optimizers.random (module)@\spxentry{misc.optimizers.random}\spxextra{module}}\index{RandomOptimizer (class in misc.optimizers.random)@\spxentry{RandomOptimizer}\spxextra{class in misc.optimizers.random}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/misc.optimizers:misc.optimizers.random.RandomOptimizer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{misc.optimizers.random.}}\sphinxbfcode{\sphinxupquote{RandomOptimizer}}}{\emph{sol\_dim}, \emph{popsize}, \emph{tf\_session}, \emph{upper\_bound=None}, \emph{lower\_bound=None}}{}
Bases: {\hyperref[\detokenize{_modules/misc.optimizers:misc.optimizers.optimizer.Optimizer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{misc.optimizers.optimizer.Optimizer}}}}}

Random shooting optimisation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sol\_dim}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The dimensionality of the problem space

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{popsize}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of candidate solutions to be sampled at every iteration

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{num\_elites}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of top solutions that will be used to obtain the distribution
at the next iteration.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tf\_session}} (\sphinxstyleliteralemphasis{\sphinxupquote{tf.Session}}) \textendash{} (optional) Session to be used for this optimizer. Defaults to None,
in which case any functions passed in cannot be tf.Tensor-valued.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{upper\_bound}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}) \textendash{} An array of upper bounds

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lower\_bound}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}) \textendash{} An array of lower bounds

\end{itemize}

\end{description}\end{quote}
\index{obtain\_solution() (misc.optimizers.random.RandomOptimizer method)@\spxentry{obtain\_solution()}\spxextra{misc.optimizers.random.RandomOptimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/misc.optimizers:misc.optimizers.random.RandomOptimizer.obtain_solution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{obtain\_solution}}}{\emph{*args}, \emph{**kwargs}}{}
Optimizes the cost function provided in setup().
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{init\_mean}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} The mean of the initial candidate distribution.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{init\_var}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} The variance of the initial candidate distribution.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{reset() (misc.optimizers.random.RandomOptimizer method)@\spxentry{reset()}\spxextra{misc.optimizers.random.RandomOptimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/misc.optimizers:misc.optimizers.random.RandomOptimizer.reset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Function iteratively called at MPC.act()

\end{fulllineitems}

\index{setup() (misc.optimizers.random.RandomOptimizer method)@\spxentry{setup()}\spxextra{misc.optimizers.random.RandomOptimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/misc.optimizers:misc.optimizers.random.RandomOptimizer.setup}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setup}}}{\emph{cost\_function}, \emph{tf\_compatible}}{}
Sets up this optimizer using a given cost function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cost\_function}} (\sphinxstyleliteralemphasis{\sphinxupquote{func}}) \textendash{} A function for computing costs over a batch of candidate solutions.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tf\_compatible}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} True if the cost function provided is tf.Tensor-valued.

\end{itemize}

\end{description}\end{quote}

Returns: None

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{_modules/misc.optimizers:module-misc.optimizers}}\label{\detokenize{_modules/misc.optimizers:module-contents}}\index{misc.optimizers (module)@\spxentry{misc.optimizers}\spxextra{module}}

\subsection{Submodules}
\label{\detokenize{_modules/misc:submodules}}

\subsection{misc.DotmapUtils module}
\label{\detokenize{_modules/misc:module-misc.DotmapUtils}}\label{\detokenize{_modules/misc:misc-dotmaputils-module}}\index{misc.DotmapUtils (module)@\spxentry{misc.DotmapUtils}\spxextra{module}}\index{get\_required\_argument() (in module misc.DotmapUtils)@\spxentry{get\_required\_argument()}\spxextra{in module misc.DotmapUtils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/misc:misc.DotmapUtils.get_required_argument}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{misc.DotmapUtils.}}\sphinxbfcode{\sphinxupquote{get\_required\_argument}}}{\emph{dotmap}, \emph{key}, \emph{message}, \emph{default=None}}{}
Returns an argument from a dotmap object, raises and error if it does not exist.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dotmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{dotmap}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{key}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{message}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Error message to be raised.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Module contents}
\label{\detokenize{_modules/misc:module-misc}}\label{\detokenize{_modules/misc:module-contents}}\index{misc (module)@\spxentry{misc}\spxextra{module}}

\section{utils package}
\label{\detokenize{_modules/utils:utils-package}}\label{\detokenize{_modules/utils::doc}}

\subsection{Submodules}
\label{\detokenize{_modules/utils:submodules}}

\subsection{utils.ModelScaler module}
\label{\detokenize{_modules/utils:module-utils.ModelScaler}}\label{\detokenize{_modules/utils:utils-modelscaler-module}}\index{utils.ModelScaler (module)@\spxentry{utils.ModelScaler}\spxextra{module}}\index{ModelScaler (class in utils.ModelScaler)@\spxentry{ModelScaler}\spxextra{class in utils.ModelScaler}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/utils:utils.ModelScaler.ModelScaler}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{utils.ModelScaler.}}\sphinxbfcode{\sphinxupquote{ModelScaler}}}{\emph{xdim=None}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Normalise the inputs and outputs to the NN model.
\index{fit() (utils.ModelScaler.ModelScaler method)@\spxentry{fit()}\spxextra{utils.ModelScaler.ModelScaler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/utils:utils.ModelScaler.ModelScaler.fit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fit}}}{\emph{inputs}, \emph{targets}}{}
Fits the scaler to the model inputs and targets.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inputs}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{tf.Tensor}}) \textendash{} shape N x 16 + 2

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{targets}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{tf.Tensor}}) \textendash{} shape N x 16

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_vars() (utils.ModelScaler.ModelScaler method)@\spxentry{get\_vars()}\spxextra{utils.ModelScaler.ModelScaler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/utils:utils.ModelScaler.ModelScaler.get_vars}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_vars}}}{}{}
Returns the tf.variables of the scaler objects used

\end{fulllineitems}

\index{inverse\_transformInput() (utils.ModelScaler.ModelScaler method)@\spxentry{inverse\_transformInput()}\spxextra{utils.ModelScaler.ModelScaler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/utils:utils.ModelScaler.ModelScaler.inverse_transformInput}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inverse\_transformInput}}}{\emph{input}}{}
Returns the inverse transform of the inputs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{input}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{tf.Tensor}}) \textendash{} shape N x nS + nU or M x N x nS + nU

\item[{Returns}] \leavevmode
shape N x nS + nU or M x N x nS + nU

\item[{Return type}] \leavevmode
np.array or tf.Tensor

\end{description}\end{quote}

\end{fulllineitems}

\index{inverse\_transformOutput() (utils.ModelScaler.ModelScaler method)@\spxentry{inverse\_transformOutput()}\spxextra{utils.ModelScaler.ModelScaler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/utils:utils.ModelScaler.ModelScaler.inverse_transformOutput}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inverse\_transformOutput}}}{\emph{mean}, \emph{variance}}{}
Normalises the inverse transform of the targets to the NN model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mean}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{tf.Tensor}}) \textendash{} shape N x nS

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{variance}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{tf.Tensor}}) \textendash{} shape N x nS

\end{itemize}

\item[{Returns}] \leavevmode
shape N x nS

\item[{Return type}] \leavevmode
np.array or tf.Tensor

\end{description}\end{quote}

\end{fulllineitems}

\index{transformInput() (utils.ModelScaler.ModelScaler method)@\spxentry{transformInput()}\spxextra{utils.ModelScaler.ModelScaler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/utils:utils.ModelScaler.ModelScaler.transformInput}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transformInput}}}{\emph{input}}{}
Normalises the inputs to the NN model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{input}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{tf.Tensor}}) \textendash{} shape N x nS + nU or M x N x nS + nU

\item[{Returns}] \leavevmode
shape N x nS + nU or M x N x nS + nU

\item[{Return type}] \leavevmode
np.array or tf.Tensor

\end{description}\end{quote}

\end{fulllineitems}

\index{transformTarget() (utils.ModelScaler.ModelScaler method)@\spxentry{transformTarget()}\spxextra{utils.ModelScaler.ModelScaler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/utils:utils.ModelScaler.ModelScaler.transformTarget}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transformTarget}}}{\emph{targets}}{}
Normalises the targets to the NN model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{targets}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{tf.Tensor}}) \textendash{} shape N x nS

\item[{Returns}] \leavevmode
shape N x nS

\item[{Return type}] \leavevmode
np.array or tf.Tensor

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{utils.TensorStandardScaler module}
\label{\detokenize{_modules/utils:module-utils.TensorStandardScaler}}\label{\detokenize{_modules/utils:utils-tensorstandardscaler-module}}\index{utils.TensorStandardScaler (module)@\spxentry{utils.TensorStandardScaler}\spxextra{module}}\index{TensorStandardScaler (class in utils.TensorStandardScaler)@\spxentry{TensorStandardScaler}\spxextra{class in utils.TensorStandardScaler}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/utils:utils.TensorStandardScaler.TensorStandardScaler}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{utils.TensorStandardScaler.}}\sphinxbfcode{\sphinxupquote{TensorStandardScaler}}}{\emph{x\_dim}, \emph{name=0}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Helper class for automatically normalizing inputs into the network.
\index{cache() (utils.TensorStandardScaler.TensorStandardScaler method)@\spxentry{cache()}\spxextra{utils.TensorStandardScaler.TensorStandardScaler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/utils:utils.TensorStandardScaler.TensorStandardScaler.cache}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cache}}}{}{}
Caches current values of this scaler.

Returns: None.

\end{fulllineitems}

\index{fit() (utils.TensorStandardScaler.TensorStandardScaler method)@\spxentry{fit()}\spxextra{utils.TensorStandardScaler.TensorStandardScaler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/utils:utils.TensorStandardScaler.TensorStandardScaler.fit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fit}}}{\emph{data}}{}
Runs two ops, one for assigning the mean of the data to the internal mean, and
another for assigning the standard deviation of the data to the internal standard deviation.
This function must be called within a ‘with \textless{}session\textgreater{}.as\_default()’ block.

Arguments:
data (np.ndarray): A numpy array containing the input

Returns: None.

\end{fulllineitems}

\index{get\_vars() (utils.TensorStandardScaler.TensorStandardScaler method)@\spxentry{get\_vars()}\spxextra{utils.TensorStandardScaler.TensorStandardScaler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/utils:utils.TensorStandardScaler.TensorStandardScaler.get_vars}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_vars}}}{}{}
Returns a list of variables managed by this object.

Returns: (list\textless{}tf.Variable\textgreater{}) The list of variables.

\end{fulllineitems}

\index{inverse\_transform() (utils.TensorStandardScaler.TensorStandardScaler method)@\spxentry{inverse\_transform()}\spxextra{utils.TensorStandardScaler.TensorStandardScaler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/utils:utils.TensorStandardScaler.TensorStandardScaler.inverse_transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inverse\_transform}}}{\emph{data}}{}
Undoes the transformation performed by this scaler.

Arguments:
data (np.array): A numpy array containing the points to be transformed.

Returns: (np.array) The transformed dataset.

\end{fulllineitems}

\index{load\_cache() (utils.TensorStandardScaler.TensorStandardScaler method)@\spxentry{load\_cache()}\spxextra{utils.TensorStandardScaler.TensorStandardScaler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/utils:utils.TensorStandardScaler.TensorStandardScaler.load_cache}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load\_cache}}}{}{}
Loads values from the cache

Returns: None.

\end{fulllineitems}

\index{transform() (utils.TensorStandardScaler.TensorStandardScaler method)@\spxentry{transform()}\spxextra{utils.TensorStandardScaler.TensorStandardScaler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/utils:utils.TensorStandardScaler.TensorStandardScaler.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{data}}{}
Transforms the input matrix data using the parameters of this scaler.

Arguments:
data (np.array): A numpy array containing the points to be transformed.

Returns: (np.array) The transformed dataset.

\end{fulllineitems}


\end{fulllineitems}

\index{TensorStandardScaler1D (class in utils.TensorStandardScaler)@\spxentry{TensorStandardScaler1D}\spxextra{class in utils.TensorStandardScaler}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/utils:utils.TensorStandardScaler.TensorStandardScaler1D}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{utils.TensorStandardScaler.}}\sphinxbfcode{\sphinxupquote{TensorStandardScaler1D}}}{\emph{name=0}}{}
Bases: {\hyperref[\detokenize{_modules/utils:utils.TensorStandardScaler.TensorStandardScaler}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{utils.TensorStandardScaler.TensorStandardScaler}}}}}

Helper class for automatically normalizing inputs into the network.
\index{fit() (utils.TensorStandardScaler.TensorStandardScaler1D method)@\spxentry{fit()}\spxextra{utils.TensorStandardScaler.TensorStandardScaler1D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/utils:utils.TensorStandardScaler.TensorStandardScaler1D.fit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fit}}}{\emph{data}}{}
Runs two ops, one for assigning the mean of the data to the internal mean, and
another for assigning the standard deviation of the data to the internal standard deviation.
This function must be called within a ‘with \textless{}session\textgreater{}.as\_default()’ block.

Arguments:
data (np.ndarray): A numpy array containing the input

Returns: None.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Module contents}
\label{\detokenize{_modules/utils:module-utils}}\label{\detokenize{_modules/utils:module-contents}}\index{utils (module)@\spxentry{utils}\spxextra{module}}

\section{AconitySTUDIO\_client module}
\label{\detokenize{_modules/AconitySTUDIO_client:module-AconitySTUDIO_client}}\label{\detokenize{_modules/AconitySTUDIO_client:aconitystudio-client-module}}\label{\detokenize{_modules/AconitySTUDIO_client::doc}}\index{AconitySTUDIO\_client (module)@\spxentry{AconitySTUDIO\_client}\spxextra{module}}\index{AconitySTUDIO\_client (class in AconitySTUDIO\_client)@\spxentry{AconitySTUDIO\_client}\spxextra{class in AconitySTUDIO\_client}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{AconitySTUDIO\_client.}}\sphinxbfcode{\sphinxupquote{AconitySTUDIO\_client}}}{\emph{login\_data}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

The AconitySTUDIO Python Client. Allows for easy automation and job
management.

For example usages, please consult the examples folder
in the root directory from this repository.

To create the client call the \sphinxtitleref{classmethod} create.
\index{change\_global\_parameter() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{change\_global\_parameter()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.change_global_parameter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{change\_global\_parameter}}}{\emph{param}, \emph{value}, \emph{check\_boundaries=True}}{}
Change a global parameter in the locally saved job and synchronizes this change with the Server Database.

If the parameter may only have values confined in a certain range, the new value will be changed to fit these requirements.
(Example: The parameter must lie in the interval {[}1, 10{]}. If the attempted change is to set the value to 12 the function sets it to 10.)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{param}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The parameter to be changed. Example: ‘supply\_factor’

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{int/float/bool}}) \textendash{} The new value of the parameter to be changed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{check\_boundaries}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Ignore min and max values of a parameter.

\end{itemize}

\end{description}\end{quote}

Note: Calling this function does not mean that a running job
will be paused and resumed with the updated value.

\end{fulllineitems}

\index{change\_part\_parameter() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{change\_part\_parameter()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.change_part_parameter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{change\_part\_parameter}}}{\emph{part\_id}, \emph{param}, \emph{value}, \emph{laser='*'}, \emph{check\_boundaries=True}}{}
Change a part parameter in the locally saved job and synchronizes this change with the Server Database.

If the parameter may only have values confined in a certain range, the new value will be changed to fit these requirements.
(Example: The parameter must lie in the interval {[}1, 10{]}. If the attempted change is to set the value to 12 the function sets it to 10.)

Note: Calling this function does not mean that a running job
will be paused and resumed with the updated value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{part\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The part id to be changed. For example, this number can be seen
in the GUI inside the jobs view -\textgreater{} clicking on a part -\textgreater{} expanding the part -\textgreater{}
a number within “{[} {]}” is appearing.
Other possibility: In the Script tab -\textgreater{} Init/Resume there are lines like
“\$p.add(4,2,\_modelsection\_002\_s1\_vs)”. part\_id -\textgreater{} 4.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{param}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The parameter to be changed. Example: ‘laser\_power’

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{int/float/bool}}) \textendash{} The new value of the parameter to be changed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{laser}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Used to select the scanner. Either ‘*’ (-\textgreater{}”Scanner All”) or 1, 2, 3, 4 etc …

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{check\_boundaries}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Ignore min and max values of a parameter.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{config\_exists() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{config\_exists()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.config_exists}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{config\_exists}}}{\emph{config\_name=None}, \emph{config\_id=None}}{}
Checks if a config exists.

One can \sphinxstyleemphasis{either} use the config\_name or the config\_id as a search parameter (XOR).
If this is not done, raises a ValueError.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{config\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the config

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{config\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Id of the config

\end{itemize}

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{config\_has\_component() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{config\_has\_component()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.config_has_component}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{config\_has\_component}}}{\emph{component}, \emph{config\_id=None}}{}
Checks if a config has a certain component.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{component}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The component to be checked.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{config\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Config Id. If \sphinxtitleref{config\_id == None}, the client uses its own attribute config\_id.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{config\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Config Name.

\end{itemize}

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{config\_state() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{config\_state()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.config_state}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{config\_state}}}{\emph{config\_id=None}}{}
Returns the current state of the config
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{config\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Id of the config. If none is given, the client uses its own attribute \sphinxtitleref{config\_id}.

\item[{Returns}] \leavevmode
‘operational’, ‘inactive’, or ‘initialized’

\item[{Return type}] \leavevmode
string

\end{description}\end{quote}

\end{fulllineitems}

\index{create() (AconitySTUDIO\_client.AconitySTUDIO\_client class method)@\spxentry{create()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.create}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{create}}}{\emph{login\_data}}{}
Factory class method to initialize a client.
Convenient as this function takes care of logging in and creating a websocket connection.
It will also set set up a ping, to ensure the connection will not be lost.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{login\_data}} (\sphinxstyleliteralemphasis{\sphinxupquote{dictionary}}) \textendash{} required keys are \sphinxtitleref{rest\_url}, \sphinxtitleref{ws\_url}, \sphinxtitleref{password} and \sphinxtitleref{email}.

\end{description}\end{quote}

Usage:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{login\PYGZus{}data} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rest\PYGZus{}url}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{http://192.168.1.1:2000}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ws\PYGZus{}url}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ws://192.168.1.1:2000}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{email}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{admin@yourcompany.com}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{password}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}password\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{p}{\PYGZcb{}}
\PYG{n}{client} \PYG{o}{=} \PYG{k}{await} \PYG{n}{AconitySTUDIO\PYGZus{}client}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{n}{login\PYGZus{}data}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{download\_chunkwise() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{download\_chunkwise()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.download_chunkwise}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{download\_chunkwise}}}{\emph{url}, \emph{save\_to}, \emph{chunk\_size=1024}}{}
\end{fulllineitems}

\index{enable\_pymongo\_database() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{enable\_pymongo\_database()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.enable_pymongo_database}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{enable\_pymongo\_database}}}{\emph{name='database\_test'}, \emph{keep\_last=120}}{}
Setup for the Mongodatabase
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mongodatabase}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} name of the database

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{keep\_last}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} If larger that zero, automatically delete entries older than keep\_last seconds

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{execute() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{execute()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.execute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{execute}}}{\emph{channel}, \emph{script}, \emph{machine\_id=None}}{}
Sends scripts (commands) to the WebSocket Server.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{machine\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Machine ID

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{channel}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} currently only “manual” is supported

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{script}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The command(s) that the Server executes

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{get()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.get}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get}}}{\emph{url}, \emph{log\_level='debug'}, \emph{logger=True}, \emph{headers=\{\}}, \emph{verbose=False}, \emph{timeout=300}}{}
The client sends a get request to the Server.
If the response status is != 200, raises a http Exception.
If the response status is 200, returns the body of the return json.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{url}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} request url, which will get added to self.rest\_url.
For example, to call the route \sphinxurl{http://192.168.1.123:9000/machines/functions}
the url is “machines/functions”.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_config\_id() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{get\_config\_id()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.get_config_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_config\_id}}}{\emph{config\_name}}{}
Returns the config\_id of the config with the given name.

If it is not unique or no config with the given name is found, raises a ValueError.
In this case, start the Browser based GUI AconitySTUDIO and copy the id from the URL and manually set the attribute config\_id.

Saves the config\_id into self.config\_id.
Saves the name of the operational config into self.config\_name.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Config ID

\item[{Return type}] \leavevmode
string

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_job\_id() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{get\_job\_id()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.get_job_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_job\_id}}}{\emph{job\_name}}{}
Get the job id for a given jobname. If the job\_name is unique, sets and returns the attribute job\_id.
If it is not unique or no job with the given name is found, raises a ValueError.
In this case, start the Browser based GUI AconitySTUDIO and copy the id from the URL and manually set the attribute machine\_id.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{job\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} jobname

\item[{Returns}] \leavevmode
Job ID

\item[{Return type}] \leavevmode
string

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_lasers() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{get\_lasers()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.get_lasers}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_lasers}}}{}{}
Returns a list with all lasers.

If no config\_id is set, raises an AttributeError

\end{fulllineitems}

\index{get\_lasers\_off\_cmds() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{get\_lasers\_off\_cmds()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.get_lasers_off_cmds}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_lasers\_off\_cmds}}}{}{}
Returns the command to turn the laser off.

\end{fulllineitems}

\index{get\_last\_built\_layer() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{get\_last\_built\_layer()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.get_last_built_layer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_built\_layer}}}{}{}
When a job is running, a websockets receives information about how many addLayerCommands have been executed.
This information is used to calculate the current layer number by adding it to the starting layer which was specified when a job was started.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
current layer number during a job

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_machine\_id() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{get\_machine\_id()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.get_machine_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_machine\_id}}}{\emph{machine\_name}}{}
Get the machine\_id from a given Machine Name.

If no or multiple machines with the given name are given, raises ValueErrors.
In this case, start the Browser based GUI AconitySTUDIO and copy the id from the URL and manually set the attribute machine\_id.

If successfull, returns the machine\_id and saves it to self.machine\_id.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{machine\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Name of Machine

\item[{Returns}] \leavevmode
Machine ID

\item[{Return type}] \leavevmode
string

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_session\_id() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{get\_session\_id()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.get_session_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_session\_id}}}{\emph{n=-1}}{}
Get all session ids. If successfull, saves the session ID in self.session\_id
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} With the default parameter \sphinxtitleref{n=-1}, the most recent session id gets saved to self.session\_id (second last session, use n=-2 etc).

\item[{Returns}] \leavevmode
Session ID

\item[{Return type}] \leavevmode
string

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_workunit\_and\_channel\_id() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{get\_workunit\_and\_channel\_id()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.get_workunit_and_channel_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_workunit\_and\_channel\_id}}}{\emph{result=None}}{}
Retrieves workunit\_id and channel\_id. If successfull,
saves them in self.channel\_id and self.workunit\_id and returns them

If not successfull, raises a ValueError.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
workunit\_id, channel\_id

\item[{Return type}] \leavevmode
tuple

\end{description}\end{quote}

\end{fulllineitems}

\index{pause\_job() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{pause\_job()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.pause_job}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pause\_job}}}{\emph{workunit\_id=None}, \emph{channel\_id='run0'}}{}
Pauses the running script on the given channel and workunit
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{workunit\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the route GET /script yields information about the current workunit\_id

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{channel}} \textendash{} the route GET /script yields information about the current workunit\_id

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{post() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{post()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.post}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{post}}}{\emph{url}, \emph{data=None}, \emph{files=None}, \emph{headers=\{\}}, \emph{timeout=300}}{}
The client sends a post request to the Server.
If the response status is 200, returns the body of the return json,
else a http exception is raised.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{url}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} request url, will get added to self.rest\_url (for details see get())

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} data to be posted

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{post\_script() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{post\_script()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.post_script}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{post\_script}}}{\emph{init\_script=''}, \emph{execution\_script=''}, \emph{job\_id=None}, \emph{channel\_id='run0'}, \emph{file\_path\_init\_script=None}, \emph{file\_path\_execution\_script=None}}{}
The client posts execution and init/resume scripts to the Server.

If the response status is != 200, raises Exception.
Returns the body of the return json.

It is recommended that the API function \sphinxtitleref{start\_job} is used instead of this function, because \sphinxtitleref{start\_job} generates the init\_script automatically.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} data to be posted

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{job\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} job\_id of the job

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{channel\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} channel\_id of the job, for instance “run0”.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{execution\_script}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} execution script

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{init\_script}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} init script

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_path\_execution\_script}} \textendash{} If != None, gets interpreted as a filepath. The file will be read and any string given to parameter execution\_script is ignored.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_path\_execution\_script}} \textendash{} string

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_path\_init\_script}} \textendash{} If != None, gets interpreted as a filepath. The file will be read and any string given to parameter init\_script is ignored.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_path\_init\_script}} \textendash{} string

\end{itemize}

\item[{Returns}] \leavevmode
Returns the body of the return json from the request.

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{put() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{put()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.put}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{put}}}{\emph{url}, \emph{data=None}, \emph{files=None}, \emph{headers=\{\}}}{}
The client sends a put request to the Server.
If the response status is 200, returns the body of the return json,
else a http exception is raised.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{url}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} request url, will get added to self.rest\_url (for details see get())

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} data to be posted

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{restart\_config() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{restart\_config()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.restart_config}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{restart\_config}}}{}{}
The attribute “config\_id” must be set.
Restarts the config with that id.

If no \sphinxcode{\sphinxupquote{config\_id}} is set, raises a ValueError.

\end{fulllineitems}

\index{resume\_job() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{resume\_job()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.resume_job}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{resume\_job}}}{\emph{layers=None}, \emph{parts='all'}, \emph{workunit\_id=None}, \emph{channel\_id='run0'}}{}
Resumes the running job on the given channel and workunit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{init\_resume\_script}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the init/resume script.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{workunit\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the route GET /script yields information about the current workunit\_id

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{channel}} \textendash{} the route GET /script yields information about the current workunit\_id

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{resume\_script() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{resume\_script()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.resume_script}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{resume\_script}}}{\emph{init\_resume\_script}, \emph{workunit\_id=None}, \emph{channel\_id='run0'}, \emph{file\_path\_given=False}}{}
Resumes the running script on the given channel and workunit.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{init\_resume\_script}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the init/resume script.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{workunit\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the route GET /script yields information about the current workunit\_id. If workunit\_id = None, the client attempts to use its own attribute workunit\_id. If that fails, raises ValueError.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{channel}} \textendash{} the route GET /script yields information about the current workunit\_id

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_data\_to\_pymongo\_db() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{save\_data\_to\_pymongo\_db()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.save_data_to_pymongo_db}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save\_data\_to\_pymongo\_db}}}{}{}
Continually saves the output of the WebSocket Server
by saving it into a Mongo database
Call enable\_pymongo\_database() before calling this function

\end{fulllineitems}

\index{start\_job() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{start\_job()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.start_job}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{start\_job}}}{\emph{layers}, \emph{execution\_script}, \emph{job\_id=None}, \emph{channel\_id='run0'}, \emph{parts='all'}}{}
Starts a job. The init/resume script will be generated automatically from the current job.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{execution\_script}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The execution script which shall be executed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{job\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Id of the Job. Get it by calling get\_job\_id().

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{channel\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} ‘run0’.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{layers}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} Specify the layers which shall be built. Must be given as list with 2 integer entries

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{parts}} (\sphinxstyleliteralemphasis{\sphinxupquote{list/string}}) \textendash{} Specify the parts which shall be built. Can either be a list of integers or the string ‘all’.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{stop\_channel() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{stop\_channel()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.stop_channel}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stop\_channel}}}{\emph{channel='manual\_move'}}{}
Stops the running execution on the given channel.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{channel}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Example: ‘manual\_move’

\end{description}\end{quote}

\end{fulllineitems}

\index{stop\_job() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{stop\_job()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.stop_job}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stop\_job}}}{\emph{workunit\_id=None}, \emph{channel='run0'}}{}
Stops the running script on the given channel and workunit
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{workunit\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the route GET /script yields information about the current workunit\_id

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{channel}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} the route GET /script yields information about the current channel

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{subscribe\_report() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{subscribe\_report()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.subscribe_report}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{subscribe\_report}}}{\emph{name}}{}
Subscribes to reports via the WebServer.

To get information about the reports use the route configurations/\{client.config\_id\}/topics).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} name of report, example reports: ‘state’, ‘task’.

\end{description}\end{quote}

\end{fulllineitems}

\index{subscribe\_topic() (AconitySTUDIO\_client.AconitySTUDIO\_client method)@\spxentry{subscribe\_topic()}\spxextra{AconitySTUDIO\_client.AconitySTUDIO\_client method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_client:AconitySTUDIO_client.AconitySTUDIO_client.subscribe_topic}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{subscribe\_topic}}}{\emph{name}}{}
Subscribes to reports via the WebServer.

To get information about the topics use the route configurations/\{client.config\_id\}/topics).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} name of topic. Examples are ‘State’, ‘Sensor’,’cmds’ and ‘Positioning’.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{AconitySTUDIO\_utils module}
\label{\detokenize{_modules/AconitySTUDIO_utils:module-AconitySTUDIO_utils}}\label{\detokenize{_modules/AconitySTUDIO_utils:aconitystudio-utils-module}}\label{\detokenize{_modules/AconitySTUDIO_utils::doc}}\index{AconitySTUDIO\_utils (module)@\spxentry{AconitySTUDIO\_utils}\spxextra{module}}\index{JobHandler (class in AconitySTUDIO\_utils)@\spxentry{JobHandler}\spxextra{class in AconitySTUDIO\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.JobHandler}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{AconitySTUDIO\_utils.}}\sphinxbfcode{\sphinxupquote{JobHandler}}}{\emph{job}, \emph{logger}, \emph{studio\_version}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

The Python Client uses this Class to modify a job locally (so it can later be uploaded to the Server database).
Additionally, it uses the locally saved job to create init and init\_resume scripts
The user of the Python Client never needs to use this class directly.
\index{change\_global\_parameter() (AconitySTUDIO\_utils.JobHandler method)@\spxentry{change\_global\_parameter()}\spxextra{AconitySTUDIO\_utils.JobHandler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.JobHandler.change_global_parameter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{change\_global\_parameter}}}{\emph{param}, \emph{new\_value}, \emph{check\_boundaries=True}}{}
Function to change global build parameters

\end{fulllineitems}

\index{change\_part\_parameter() (AconitySTUDIO\_utils.JobHandler method)@\spxentry{change\_part\_parameter()}\spxextra{AconitySTUDIO\_utils.JobHandler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.JobHandler.change_part_parameter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{change\_part\_parameter}}}{\emph{part\_id}, \emph{param}, \emph{new\_value}, \emph{laser='*'}, \emph{check\_boundaries=True}}{}
Function to build parameters for individual parts

\end{fulllineitems}

\index{convert\_to\_string() (AconitySTUDIO\_utils.JobHandler method)@\spxentry{convert\_to\_string()}\spxextra{AconitySTUDIO\_utils.JobHandler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.JobHandler.convert_to_string}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{convert\_to\_string}}}{\emph{data=None}}{}
Convert input data type into a sring.

\end{fulllineitems}

\index{create\_addParts() (AconitySTUDIO\_utils.JobHandler method)@\spxentry{create\_addParts()}\spxextra{AconitySTUDIO\_utils.JobHandler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.JobHandler.create_addParts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_addParts}}}{}{}
Returns the commands to add parts to the job

\end{fulllineitems}

\index{create\_init\_resume\_script() (AconitySTUDIO\_utils.JobHandler method)@\spxentry{create\_init\_resume\_script()}\spxextra{AconitySTUDIO\_utils.JobHandler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.JobHandler.create_init_resume_script}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_init\_resume\_script}}}{\emph{layers}, \emph{parts='all'}}{}
Message to resume the execution of a script

\end{fulllineitems}

\index{create\_init\_script() (AconitySTUDIO\_utils.JobHandler method)@\spxentry{create\_init\_script()}\spxextra{AconitySTUDIO\_utils.JobHandler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.JobHandler.create_init_script}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_init\_script}}}{\emph{layers}, \emph{parts='all'}}{}
Message to start the execution of a script

\end{fulllineitems}

\index{create\_laser\_beam\_sources() (AconitySTUDIO\_utils.JobHandler method)@\spxentry{create\_laser\_beam\_sources()}\spxextra{AconitySTUDIO\_utils.JobHandler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.JobHandler.create_laser_beam_sources}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_laser\_beam\_sources}}}{\emph{lasers}}{}
Creates and returns a dictionary containing the laser beam sources

\end{fulllineitems}

\index{create\_preStartParams() (AconitySTUDIO\_utils.JobHandler method)@\spxentry{create\_preStartParams()}\spxextra{AconitySTUDIO\_utils.JobHandler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.JobHandler.create_preStartParams}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_preStartParams}}}{}{}
Returns the parameters set before the start of the build

\end{fulllineitems}

\index{create\_preStartSelection() (AconitySTUDIO\_utils.JobHandler method)@\spxentry{create\_preStartSelection()}\spxextra{AconitySTUDIO\_utils.JobHandler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.JobHandler.create_preStartSelection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_preStartSelection}}}{\emph{layers}, \emph{parts}}{}
Select the parts to be used

\end{fulllineitems}

\index{get\_lasers() (AconitySTUDIO\_utils.JobHandler method)@\spxentry{get\_lasers()}\spxextra{AconitySTUDIO\_utils.JobHandler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.JobHandler.get_lasers}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_lasers}}}{}{}
Returns the available lasers

\end{fulllineitems}

\index{get\_mapping\_parts\_to\_index() (AconitySTUDIO\_utils.JobHandler method)@\spxentry{get\_mapping\_parts\_to\_index()}\spxextra{AconitySTUDIO\_utils.JobHandler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.JobHandler.get_mapping_parts_to_index}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_mapping\_parts\_to\_index}}}{}{}
Returns the indices of the job parts

\end{fulllineitems}

\index{set() (AconitySTUDIO\_utils.JobHandler method)@\spxentry{set()}\spxextra{AconitySTUDIO\_utils.JobHandler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.JobHandler.set}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set}}}{\emph{job}}{}
Set the internal job variable to the input job

\end{fulllineitems}

\index{to\_json() (AconitySTUDIO\_utils.JobHandler method)@\spxentry{to\_json()}\spxextra{AconitySTUDIO\_utils.JobHandler method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.JobHandler.to_json}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{to\_json}}}{}{}
Convert current job to json

\end{fulllineitems}


\end{fulllineitems}

\index{customTime() (in module AconitySTUDIO\_utils)@\spxentry{customTime()}\spxextra{in module AconitySTUDIO\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.customTime}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{AconitySTUDIO\_utils.}}\sphinxbfcode{\sphinxupquote{customTime}}}{\emph{*args}}{}
Converts time to the local machine timezone.

\end{fulllineitems}

\index{filter\_out\_keys() (in module AconitySTUDIO\_utils)@\spxentry{filter\_out\_keys()}\spxextra{in module AconitySTUDIO\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.filter_out_keys}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{AconitySTUDIO\_utils.}}\sphinxbfcode{\sphinxupquote{filter\_out\_keys}}}{\emph{data, allowed={[}'name', 'type', 'value'{]}}}{}
Loop through input dictionary and only retain the ‘name’, ‘type’, ‘value’ keys

\end{fulllineitems}

\index{fix\_ws\_msg() (in module AconitySTUDIO\_utils)@\spxentry{fix\_ws\_msg()}\spxextra{in module AconitySTUDIO\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.fix_ws_msg}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{AconitySTUDIO\_utils.}}\sphinxbfcode{\sphinxupquote{fix\_ws\_msg}}}{\emph{msg}, \emph{replace\_value=-1}}{}
\end{fulllineitems}

\index{get\_adress() (in module AconitySTUDIO\_utils)@\spxentry{get\_adress()}\spxextra{in module AconitySTUDIO\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.get_adress}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{AconitySTUDIO\_utils.}}\sphinxbfcode{\sphinxupquote{get\_adress}}}{\emph{args}}{}
Return the address of the machine

\end{fulllineitems}

\index{get\_time\_string() (in module AconitySTUDIO\_utils)@\spxentry{get\_time\_string()}\spxextra{in module AconitySTUDIO\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.get_time_string}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{AconitySTUDIO\_utils.}}\sphinxbfcode{\sphinxupquote{get\_time\_string}}}{\emph{raw\_time\_stamp}, \emph{format='\%b \%d \%H:\%M:\%S'}}{}
Return a string with the current time

\end{fulllineitems}

\index{log\_setup() (in module AconitySTUDIO\_utils)@\spxentry{log\_setup()}\spxextra{in module AconitySTUDIO\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.log_setup}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{AconitySTUDIO\_utils.}}\sphinxbfcode{\sphinxupquote{log\_setup}}}{\emph{filename}, \emph{directory\_path=''}}{}
Initialise the logging functionality

\end{fulllineitems}

\index{track\_layer\_number() (in module AconitySTUDIO\_utils)@\spxentry{track\_layer\_number()}\spxextra{in module AconitySTUDIO\_utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{_modules/AconitySTUDIO_utils:AconitySTUDIO_utils.track_layer_number}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{AconitySTUDIO\_utils.}}\sphinxbfcode{\sphinxupquote{track\_layer\_number}}}{\emph{client}, \emph{msg}}{}
Update the current layer class attribute

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{a}
\item\relax\sphinxstyleindexentry{AconitySTUDIO\_client}\sphinxstyleindexpageref{_modules/AconitySTUDIO_client:\detokenize{module-AconitySTUDIO_client}}
\item\relax\sphinxstyleindexentry{AconitySTUDIO\_utils}\sphinxstyleindexpageref{_modules/AconitySTUDIO_utils:\detokenize{module-AconitySTUDIO_utils}}
\indexspace
\bigletter{c}
\item\relax\sphinxstyleindexentry{cluster}\sphinxstyleindexpageref{_modules/cluster:\detokenize{module-cluster}}
\item\relax\sphinxstyleindexentry{controllers}\sphinxstyleindexpageref{_modules/controllers:\detokenize{module-controllers}}
\item\relax\sphinxstyleindexentry{controllers.Controller}\sphinxstyleindexpageref{_modules/controllers:\detokenize{module-controllers.Controller}}
\item\relax\sphinxstyleindexentry{controllers.MPC}\sphinxstyleindexpageref{_modules/controllers:\detokenize{module-controllers.MPC}}
\indexspace
\bigletter{l}
\item\relax\sphinxstyleindexentry{layers}\sphinxstyleindexpageref{_modules/layers:\detokenize{module-layers}}
\item\relax\sphinxstyleindexentry{layers.FC}\sphinxstyleindexpageref{_modules/layers:\detokenize{module-layers.FC}}
\indexspace
\bigletter{m}
\item\relax\sphinxstyleindexentry{machine}\sphinxstyleindexpageref{_modules/machine:\detokenize{module-machine}}
\item\relax\sphinxstyleindexentry{misc}\sphinxstyleindexpageref{_modules/misc:\detokenize{module-misc}}
\item\relax\sphinxstyleindexentry{misc.DotmapUtils}\sphinxstyleindexpageref{_modules/misc:\detokenize{module-misc.DotmapUtils}}
\item\relax\sphinxstyleindexentry{misc.optimizers}\sphinxstyleindexpageref{_modules/misc.optimizers:\detokenize{module-misc.optimizers}}
\item\relax\sphinxstyleindexentry{misc.optimizers.cem}\sphinxstyleindexpageref{_modules/misc.optimizers:\detokenize{module-misc.optimizers.cem}}
\item\relax\sphinxstyleindexentry{misc.optimizers.optimizer}\sphinxstyleindexpageref{_modules/misc.optimizers:\detokenize{module-misc.optimizers.optimizer}}
\item\relax\sphinxstyleindexentry{misc.optimizers.random}\sphinxstyleindexpageref{_modules/misc.optimizers:\detokenize{module-misc.optimizers.random}}
\indexspace
\bigletter{u}
\item\relax\sphinxstyleindexentry{utils}\sphinxstyleindexpageref{_modules/utils:\detokenize{module-utils}}
\item\relax\sphinxstyleindexentry{utils.ModelScaler}\sphinxstyleindexpageref{_modules/utils:\detokenize{module-utils.ModelScaler}}
\item\relax\sphinxstyleindexentry{utils.TensorStandardScaler}\sphinxstyleindexpageref{_modules/utils:\detokenize{module-utils.TensorStandardScaler}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}